# LoNalogy: Bible3（Draft）
**ステータス**: Draft（章ごとに追記して育てる）
**目的**: Bible2 の内容を整理し、「理論→実装→検証」の運用手順が迷わず辿れる形に再構成する
**スコープ**: 本書は *基盤理論 / 実装 / 検証プロトコル* を中心にする
**スコープ外**: 宇宙論（具体的モデル・数値・観測予言など）は本書では扱わない（必要になったら別冊に分離）

---

## 目次

### Part 0: 読み方
0. [このBible3の位置づけ](#0-このbible3の位置づけ)
1. [記法・規約・設計原則](#1-記法規約設計原則)

### Part I: 基礎理論（コア）
2. [複素情報波動関数 ψ と観測量](#2-複素情報波動関数-ψ-と観測量)
3. [LoNA方程式（一般形）](#3-lona方程式一般形)
4. [Lonadian Λ と安定性（dΛ/dt ≤ 0）](#4-lonadian-λ-と安定性dλdt--0)
5. [境界・ゲージ・保存項/散逸項の分解](#5-境界ゲージ保存項散逸項の分解)

### Part II: 3つのSIF系統
6. [C-SIF（連続場）](#6-c-sif連続場)
7. [D-SIF（離散グラフ）](#7-d-sif離散グラフ)
8. [jiwa-SIF（離散⟺連続の橋）](#8-jiwa-sif離散連続の橋)

### Part III: 圧縮と等価化
9. [LoNA-Thévenin（Schur補完による部分系圧縮）](#9-lona-théveninschur補完による部分系圧縮)
10. [Dirichlet-to-Neumann / 多ポート / 有効インピーダンス](#10-dirichlet-to-neumann--多ポート--有効インピーダンス)

### Part IV: Meta層（自己調整）
11. [5階層（Level 0–4）と Meta-LoNA](#11-5階層level-04と-meta-lona)
12. [安全域・射影・制御としてのLoNalogy](#12-安全域射影制御としてのlonalogy)

### Part V: 計算手法（実装）
13. [数値離散化と時間積分（C-SIF/D-SIF共通）](#13-数値離散化と時間積分c-sifd-sif共通)
14. [実装ガイド（CPU/GPU、JAX、観測API、ログ）](#14-実装ガイドcpugpujax観測apiログ)

### Part VI: 検証プロトコル（SimP/SolP）
15. [SimPループ（実験の標準手順）](#15-simpループ実験の標準手順)
16. [SimP↔SolP（数値↔証明の往復）](#16-simpsolp数値証明の往復)
17. [再現性（成果物・記録・公開/非公開の境界）](#17-再現性成果物記録公開非公開の境界)

### Part VII: 応用（宇宙論は別冊）
18. [応用テンプレ（問題→SIF選択→観測量→検証）](#18-応用テンプレ問題sif選択観測量検証)

### 付録
A. [数式一覧](#付録a-数式一覧)
B. [用語集](#付録b-用語集)
C. [コードテンプレ集](#付録c-コードテンプレ集)
D. [チェックリスト](#付録d-チェックリスト)

---

# Part 0: 読み方

## 0. このBible3の位置づけ

Bible3 は LoNalogy を「理論の説明書」ではなく、**実験と証明を往復して育てるための運用マニュアル**として整理し直した版です。

本書が扱う中心は次の3点です：

1. **対象の統一**  
   複素情報波動関数 $\psi=\sqrt{p}\,e^{iS}$ を共通の状態表現として採用し、連続（PDE）・離散（グラフ）・最適化（離散問題）を同じ言葉で書けるようにする。
2. **原理の統一**  
   「自然な進化は Lonadian $\Lambda$ を下げる（または下げようとする）」という設計原則を、連続/離散の両方で **Lyapunov（降下）として読める形**にする。  
   ここで重要なのは *$\Lambda$ が負になること* ではなく、**$d\Lambda/dt \le 0$（単調減少）**という向きである。
3. **方法論の統一（SimP↔SolP）**  
   - **SimP**: 数値実験で「どこまで収束しそうか」「何が保存/単調か」「どの量が本質か」を特定し、仮説（候補定理・候補補題・候補不変量）を作る。  
   - **SolP**: SimPで得た“当たり”を足場に、解析学的に **正しい主張（条件・誤差・境界つき）**へ落とす。  
   この往復を繰り返し、証明済みの部品（補題）を蓄積していく。

### Bible2 との違い
- Bible2 は「広く全部を一冊に置く」性格が強い。Bible3 は **再現可能な運用**を優先して、章ごとに育つ前提で書く。
- SolP は「CASで一発確認」に限定しない。CASは道具の一つであり、ここでの SolP は **人間が読めて追跡できる証明**（不等式・収束・一意性・誤差評価など）を主に指す。

### 公開前提（重要）
この文書は他者が読む可能性があるため、**接続情報・鍵・個人識別子・API等の秘匿情報は書かない**。運用上必要な情報は、公開物とは分離して管理する。

### 読み進め方（おすすめ）
- 実装したい: Part I（2–4）→ Part V（13–14）→ Part VI（15–17）
- 離散問題を解きたい: Part II（8）→ Part V（14）→ Part VI（15–16）
- 「縮約/等価化」を使いたい: Part III（9–10）→ Part VI（17）

## 1. 記法・規約・設計原則

この章は「以後の全章で同じ意味になるように」**記号・符号・用語を固定**するためのもの。  
実装や実験で表記が揺れたら、ここを優先して整合させる。

### 1.1 記号（状態と観測量）

- **状態（共通）**: 複素情報波動関数
  - 連続（C-SIF）: $\psi(x,t)$, $x \in \mathcal{D} \subset \mathbb{R}^d$
  - 離散（D-SIF）: $\psi_i(t)$, $i \in V$（グラフのノード）
- **強度**: $\rho := |\psi|^2$（連続なら密度、離散なら各ノードの強度）
- **位相**: $S := \arg(\psi)$（連続なら位相場、離散なら位相配列）
- **分解**: $\psi = \sqrt{\rho}\,e^{iS}$（可能な範囲でこの分解を基本形とする）

### 1.2 記号（空間・時間・添字）

- **時間**: $t$ は基本ダイナミクスの時間、$\tau$ は Meta 層の時間（遅い時間）  
  例: $\partial_t \psi = \mathcal{L}[\psi;\Theta]$, $\partial_\tau \Theta = \mathcal{F}[\Theta,\mathcal{H}[\psi]]$
- **添字**:
  - 連続の空間次元: $d$
  - 離散ノード: $i,j \in V$, エッジ: $(i,j)\in E$
- **複素共役**: $\bar{\psi}$（バー）

### 1.3 内積・ノルム（共通の読み替え）

“同じ式”が連続/離散で書けるように、内積を基準に揃える。

- **連続（C-SIF）**:  
  $\langle f,g\rangle := \int_{\mathcal{D}} \overline{f(x)}\,g(x)\,dx$  
  $\|f\|_2^2 := \langle f,f\rangle$
- **離散（D-SIF）**:  
  $\langle u,v\rangle := \sum_{i\in V}\overline{u_i}\,v_i$  
  $\|u\|_2^2 := \langle u,u\rangle$

（必要なら重み付き内積 $\sum w_i \bar{u_i}v_i$ を使うが、その場合は明示する。）

### 1.4 作用素（連続/離散）

- **連続**:
  - 勾配: $\nabla$
  - ラプラシアン: $\Delta := \nabla^2$
- **離散**:
  - 隣接行列: $A$
  - 次数行列: $D_g := \mathrm{diag}(\deg(i))$
  - グラフラプラシアン: $L := D_g - A$（標準形）

離散の “拡散/平滑化” は一般に $-L$ 側で働く（$L$ は半正定値）。

### 1.5 パラメータ束と「固定/可変」

- **パラメータ束**: $\Theta$  
  例: $\Theta=\{\omega_0,\gamma,D,\alpha,V,F\}$（必要に応じて追加）
- **固定 or 可変**:
  - 章の前半（理論の核）では、まず **固定パラメータ**を基本とする
  - 章の後半（Meta）で、$\Theta(\tau)$ として **自己調整（進化）**を導入する

### 1.6 Lonadian（Λ）の定義規約

- **Lonadian** $\Lambda$ は「系の形（状態）に関する汎関数/関数」で、設計上は次の性質を優先する：
  1. **下に有界**（発散を避ける）
  2. できれば **$\Lambda\ge 0$**（“尺度”として扱いやすい）
  3. 実験で観測でき、実装で計算できる
- **符号規約**:  
  “自然な進化は $\Lambda$ を下げる” を基本とし、外力が無いとき
  $$\frac{d\Lambda}{dt} \le 0$$
  を目標にダイナミクス（更新則）を設計する。
- **呼び分け**:
  - $\Lambda$（Lonadian）: 原理側（Lyapunov/降下）として扱う主役
  - 指標/メトリクス: 評価・診断に使う（$\Lambda$ と同一視しない）

### 1.7 複素微分（実装で迷わないための最小ルール）

複素状態の勾配流を書くときは、**Wirtinger 微分**の考え方に合わせて
「$\psi$ と $\bar{\psi}$ を独立変数として扱う」規約に寄せる。

- 記法: $\delta\Lambda/\delta\bar{\psi}$（$\bar{\psi}$ による汎関数微分）
- 典型形（外力なし）:
  $$\partial_t \psi = -\frac{\delta\Lambda}{\delta\bar{\psi}} \quad \Rightarrow \quad \frac{d\Lambda}{dt}\le 0$$
- “位相回転”などの保存項は別に足す（後の章で分解する）。

### 1.8 実装・公開に関する規約（重要）

- 公開される文書・リポジトリには、**接続先・鍵・トークン・個人識別子**を一切書かない。
- 実験の再現性に必要なのは「手順・式・パラメータ・成果物の形式」であり、秘匿情報ではない。
  秘匿情報は公開物から分離して管理する。

---

# Part I: 基礎理論（コア）

## 2. 複素情報波動関数 ψ と観測量

LoNalogy の基本変数は **複素情報波動関数** $\psi$ である。  
この章では「$\psi$ をどう読むか」と「実験で何を観測するか」を固定する。

### 2.1 状態表現：$\psi=\sqrt{\rho}\,e^{iS}$

基本分解：
$$\psi = \sqrt{\rho}\,e^{iS}$$

- $\rho := |\psi|^2 \ge 0$ は **強度**（存在量・密度・重み）
- $S := \arg(\psi)$ は **位相**（方向・文脈・“向き”）

連続（C-SIF）では $\rho(x,t), S(x,t)$ が場になり、離散（D-SIF）では $\rho_i(t), S_i(t)$ が配列になる。

> 注意：$\psi=0$ の点では位相が未定義になる。実装では「位相を直接扱う」よりも、$\psi$ から必要な量を計算する流儀を基本にする。

### 2.2 ゲージ（位相の基準）と同値性

位相には「基準」があり、例えば全体位相の平行移動
$$\psi \mapsto e^{i\theta}\psi$$
は多くの観測量に影響しない（$\rho$ は不変、位相差は不変）。

LoNalogyでは以下の区別を常に意識する：

- **絶対位相** $S$：基準依存（観測に入れるなら基準固定が必要）
- **位相差** $\Delta S$：基準不変（多くの物理/構造がここに乗る）

### 2.3 基本観測量（必須）

最小セットとして、常に次を観測できる形にしておく：

1. **質量（総強度）**
   - 連続：$M := \int_{\mathcal{D}} \rho(x)\,dx$
   - 離散：$M := \sum_{i\in V} \rho_i$
2. **平均強度**
   - 連続：$\bar{\rho} := \frac{1}{|\mathcal{D}|}\int_{\mathcal{D}}\rho\,dx$
   - 離散：$\bar{\rho} := \frac{1}{|V|}\sum_i \rho_i$
3. **最大/最小**
   - $\rho_{\max}, \rho_{\min}$（局在・発散・数値不安定の検知に使う）

ここまでが「壊れていないか」を判断する監視計器になる。

### 2.4 位相流と流束（“動き”の観測）

位相の空間勾配は“流れの向き”として読める。連続では
$$\mathbf{v} := \nabla S = \mathrm{Im}\left(\frac{\nabla\psi}{\psi}\right)$$
を **位相流** と呼ぶ（$\psi=0$ では注意）。

このとき強度で重み付けした
$$\mathbf{j} := \rho\,\mathbf{v}$$
を **流束** として扱える（量子力学の確率流に近い形）。

離散では「勾配」の代わりにエッジ差分を使う。例えばエッジ $(i,j)$ に対し
$$\Delta S_{ij} := S_j - S_i$$
を位相差とし、局所的には
$$j_{ij} \propto \sqrt{\rho_i\rho_j}\,\sin(\Delta S_{ij})$$
のような形が自然に出る（蔵本結合や離散シュレーディンガー系の典型）。

> ポイント：絶対位相ではなく **位相差が観測に乗る**。D-SIFの多くの現象（同期・境界・摩擦）は位相差で記述できる。

### 2.5 “粗さ”と局在：勾配・変動の観測

LoNalogyは「形」を扱うため、強度や位相の“粗さ”を観測する。

- 連続の典型：
  - 勾配強度：$G_\psi := \int |\nabla\psi|^2 dx$
  - 強度勾配：$G_\rho := \int |\nabla\rho|^2 dx$
- 離散の典型（ラプラシアン $L$ を用いる）：
  - 二次形式：$G_\psi := \langle \psi, L\psi \rangle$（平滑化の尺度）
  - 差分和：$G_\psi \propto \sum_{(i,j)\in E}|\psi_i-\psi_j|^2$
  - 強度版：$\sum_{(i,j)\in E}(\rho_i-\rho_j)^2$

これらは「拡散が効いているか」「局在が起きているか」「数値が荒れてきたか」を定量化する。

### 2.6 同期・整列：秩序パラメータ

位相が揃う/崩れる現象は多くの系で中心的になる。LoNalogyでは次の **整列指標** を基本に置く：

$$R := \left|\frac{\int \rho(x)\,e^{iS(x)}dx}{\int \rho(x)\,dx}\right| \in [0,1]$$

離散なら積分を和に置き換える：
$$R := \left|\frac{\sum_i \rho_i e^{iS_i}}{\sum_i \rho_i}\right|$$

- $R\approx 1$：位相がほぼ整列（同期）
- $R\approx 0$：位相がばらばら（非同期）

この $R$ は Meta 層で「散逸の強弱」や「探索↔活用」の切替を判断する観測量としても使える（後の章で扱う）。

### 2.7 観測ベクトル $\mathcal{H}[\psi]$（実験→証明の受け渡し）

SimP↔SolP を回すには、数値実験の結果を「証明で扱える形」に圧縮する必要がある。  
そのために、観測量の束を
$$\mathcal{H}[\psi] := (\;M,\;\bar{\rho},\;\rho_{\max},\;G_\psi,\;G_\rho,\;R,\;\ldots\;)$$
のようにまとめて扱う。

実務上のルール：

- **SolPで使う量**は、できるだけ **不等式で評価しやすい形**（二次形式、ノルム、上界/下界）に寄せる
- **SimPで見る量**は、異常検知に効く（発散・局在・位相飛び・非単調）ものを優先する

### 2.8 この章の要約（次章への橋）

- LoNalogyの状態は $\psi$ で統一し、実験では $\rho=|\psi|^2$ と位相差 $\Delta S$ を中心に読む。
- 収束・安定性の議論に繋げるため、観測量はノルムや二次形式（$M,\,G_\psi$ 等）として定義しておく。
- 次章では、これらの観測量が自然に現れる **LoNA方程式（時間発展）** を導入する。

## 3. LoNA方程式（一般形）

この章では「LoNalogyの時間発展」を、連続/離散/最適化で共通に読める形に整理する。

### 3.1 一般形：保存＋散逸＋外力＋ノイズ

LoNA方程式は、直感的には次の分解で捉える：

$$\partial_t \psi = \underbrace{\mathcal{A}[\psi;\Theta]}_{\text{保存（回転・可逆）}}
\;+\;\underbrace{\mathcal{D}[\psi;\Theta]}_{\text{散逸（降下・不可逆）}}
\;+\;\underbrace{F}_{\text{外力}}
\;+\;\underbrace{\xi}_{\text{ノイズ}}$$

- $\mathcal{A}$：位相回転や可逆な伝播（一般に“保つ側”）
- $\mathcal{D}$：Lonadian を下げる側（Lyapunov として設計する）
- $F$：入力・制約・観測フィードバックなど（符号は状況次第）
- $\xi$：探索・熱雑音・確率的摂動（期待値での安定性などは別途扱う）

以後の章では、まず $F=0,\;\xi=0$ の閉系で「何が必ず言えるか」を固め、必要に応じて $F,\xi$ を足す。

### 3.2 標準的な具体形（C-SIFの原型）

最もよく使う骨格（複素Ginzburg–Landau型）：

$$
\partial_t\psi
= (-\gamma - i\omega_0)\psi
+ D\Delta\psi
+ \alpha|\psi|^2\psi
- V(x)\psi
+ F(x,t)
+ \xi(x,t)
$$

ここで：

- $\omega_0$：位相回転（保存的）
- $\gamma\ge 0$：散逸（大きいほど早く落ち着く）
- $D$：拡散/平滑化（“粗さ”を削る）
- $\alpha$：非線形（飽和・集束・自己相互作用）
- $V$：ポテンシャル（局在・制約）

> 注意：この式は「便利な標準形」。本質は **“保存項と降下項の分解”**であり、係数や項の選び方は問題に合わせて変える。

### 3.3 Lonadian降下としての書き方（設計の核）

LoNalogyの核は「$d\Lambda/dt\le 0$ を作る」ことであり、最も直接な方法は **勾配流**にすること：

$$\partial_t\psi = -\frac{\delta\Lambda}{\delta\bar{\psi}}$$

この形なら（適切な正則性の下で）
$$\frac{d\Lambda}{dt} = -\left\|\frac{\delta\Lambda}{\delta\bar{\psi}}\right\|_2^2 \le 0$$
がただちに出る。

実務ではここに “保存項” を足す：

$$\partial_t\psi = -\frac{\delta\Lambda}{\delta\bar{\psi}} + \mathcal{A}[\psi]$$

典型例として、$\mathcal{A}[\psi]= -i\omega_0\psi$ は $\Lambda$ を変えない（全体位相の回転）。

### 3.4 連続と離散の統一：「ラプラシアン」を作用素で読む

同じ議論を連続/離散で使い回すため、線形部分を「作用素」としてまとめる：

$$\partial_t\psi = (-\gamma - i\omega_0)\psi - \mathcal{K}\psi + \mathcal{N}(\psi) + F + \xi$$

ここで $\mathcal{K}$ は「粗さを罰する半正定値作用素」：

- 連続（C-SIF）：$\mathcal{K}= -D\Delta + V(x)$（境界条件込み）
- 離散（D-SIF）：$\mathcal{K}= D L + V$（$L$ はグラフラプラシアン、$V$ は対角行列）

この読み替えを固定すると、以後の章で同じ議論（単調性・安定性・誤差評価）が流用できる。

### 3.5 離散（D-SIF）の典型形

グラフ $G=(V,E)$ 上の状態 $\psi\in\mathbb{C}^{|V|}$ に対し、基本形は

$$\dot{\psi} = (-\gamma - i\omega_0)\psi - D L\psi + \alpha\,\operatorname{diag}(|\psi|^2)\psi - V\psi + F + \xi$$

- $-DL\psi$ が「平滑化」（隣接ノードとの差を縮める）
- 非線形項は各ノードの自己相互作用（必要に応じてエッジ結合の非線形に拡張する）

### 3.6 位相と強度に分けて読む（観測への接続）

$\psi=\sqrt{\rho}e^{iS}$ とすると、LoNA方程式は

- 強度 $\rho$ の拡散/集束
- 位相 $S$ の回転/同期

の混合として読める。実装上は $\psi$ のまま更新し、観測として $(\rho,S,\Delta S)$ を計算するのが安定。

### 3.7 最適化（jiwa-SIF）への翻訳：「目的関数の降下」

離散問題を解きたいとき、状態を連続変数 $u$（または $\psi$ の強度）として持ち、
**目的関数＋離散化ペナルティ**を Lonadian として設計する：

$$\Lambda(u;\lambda) = J_{\mathrm{relax}}(u) + \lambda\,D_{\mathrm{disc}}(u) + R(u)$$

例：

- $D_{\mathrm{disc}}(u)=\sum_i u_i(1-u_i)$（$u\in[0,1]^n$ を二値へ寄せる）
- $R(u)=u^\top L u$（グラフ上での平滑化・局所性の注入）

更新は基本的に
$$\dot{u} = -\nabla_u \Lambda(u;\lambda)$$
で、$d\Lambda/dt\le 0$ がLyapunovとして成り立つ。

> 重要：この枠で保証しやすいのは「降下・停留点への収束（条件つき）」であり、一般の離散問題で“大域最適”まで保証するのは別問題になる（後の章で扱う）。

### 3.8 この章の要約（次章への橋）

- LoNA方程式は「保存（回転）＋散逸（降下）＋外力＋ノイズ」の分解で読む。
- 設計の核は $\partial_t\psi = -\delta\Lambda/\delta\bar{\psi}$ 型（Lyapunov降下）を作ること。
- 次章では、具体的な $\Lambda$ をどう選ぶと $d\Lambda/dt\le 0$ が出るか、そして何が“安定”として言えるかを整理する。

## 4. Lonadian Λ と安定性（dΛ/dt ≤ 0）

この章では LoNalogy の「安定性」を、数学的には **Lyapunov（リャプノフ）関数**としての $\Lambda$ で定義する。
重要なのは「$\Lambda$ の値が負かどうか」ではなく、**時間発展が $\Lambda$ を下げる向きにあるか**である。

### 4.1 Lonadian（Λ）とは何か

Lonadian $\Lambda$ は、状態 $\psi$（または緩和変数 $u$）に割り当てる **実数値の尺度**である。
直感的には「形の粗さ」「制約違反」「不一致」「不安定さ」をまとめた量で、設計上は次を満たすことを優先する：

1. **実数値**：$\Lambda(\psi)\in\mathbb{R}$
2. **下に有界**：$\inf \Lambda > -\infty$（暴走を防ぐ）
3. **計算可能**：SimPで毎ステップ観測できる
4. **微分可能（少なくとも降下方向が定義可能）**：SolPで $d\Lambda/dt$ を追える

### 4.2 Lyapunov降下：「閉系では下がる」を作る

最も基本の設計は **勾配流**：

$$\partial_t\psi = -\frac{\delta\Lambda}{\delta\bar{\psi}}$$

このとき（適切な正則性の下で）
$$\frac{d\Lambda}{dt} = -\left\|\frac{\delta\Lambda}{\delta\bar{\psi}}\right\|_2^2 \le 0$$

よって $\Lambda$ は Lyapunov 関数になり、少なくとも「上に発散していく」挙動は抑えられる。

### 4.3 保存項を足しても「降下」は保てる

実務では「回転（保存）」を加えたくなる。典型は

$$\partial_t\psi = -\frac{\delta\Lambda}{\delta\bar{\psi}} - i\omega_0\psi$$

この $-i\omega_0\psi$ は（全体位相の回転であり）$\Lambda$ を変えない設計にできるため、
依然として $\frac{d\Lambda}{dt}\le 0$ が保たれる。

一般化すると、次の形が便利：

$$\partial_t\psi = -\mathcal{G}\frac{\delta\Lambda}{\delta\bar{\psi}} + \mathcal{A}\psi$$

- $\mathcal{G}$：正（半）定値な作用素（「降下の計量」）
- $\mathcal{A}$：「保存」を表す作用素（$\Lambda$ を変えないように設計）

この枠は、連続/離散で同じ証明パターンを使える。

### 4.4 安定性の種類：何が「落ち着く」なのか

LoNalogyでよく使う安定性の言い方を整理する。

- **Lyapunov安定**：初期値を少しずらしても、解が大きく離れない
- **漸近安定**：時間が経つと平衡（または平衡集合）へ近づく
- **収束先**：多くの場合「一点」ではなく **臨界点集合**（$\delta\Lambda/\delta\bar{\psi}=0$ の集合）になる

勾配流では典型的に
$$\frac{d\Lambda}{dt}\le 0,\quad \int_0^\infty \left\|\frac{\delta\Lambda}{\delta\bar{\psi}}\right\|_2^2 dt < \infty$$
が得られ、解は「降下しながら臨界集合へ吸い寄せられる」という構図になる（厳密化には LaSalle の不変原理などを使う）。

### 4.5 「収束」と「最適」は別問題

離散問題（最適化）に LoNalogy を使うとき、まず保証しやすいのは：

- $\Lambda$ が下がる（降下）
- 停留点（局所最小/鞍点/平坦部）へ近づく（条件つき）

一方で「大域最適」や「最良解の一意な同定」は、問題クラスによっては原理的に難しい。
したがって LoNalogy の戦略は次の二段になる：

1. **SolPで保証する部分**：降下・安定性・誤差境界（「落ち着くこと」）
2. **SimPで攻める部分**：探索・初期値・スケジュール・多試行（「良い所に落とす」）

この役割分担を明確にしておくと、「カンニング→証明」の再帰ループが破綻しにくい。

### 4.6 代表的な Lonadian の形（連続/離散/最適化）

#### 4.6.1 C-SIF（連続場）の典型

連続場では「粗さ＋制約＋非線形」を足し合わせたエネルギー型が自然：

$$\Lambda_C[\psi] = \int_{\mathcal{D}}\left(D|\nabla\psi|^2 + V(x)|\psi|^2 + \frac{\beta}{2}|\psi|^4\right)\,dx$$

（係数名は章ごとに変わってよいが、「平方・四乗・ポテンシャル」の役割は固定する。）

#### 4.6.2 D-SIF（離散グラフ）の典型

グラフ $G=(V,E)$ 上では、連続の $\int|\nabla\psi|^2$ を
二次形式に置き換える：

$$\Lambda_D(\psi) = D\,\langle \psi, L\psi\rangle + \langle \psi, V\psi\rangle + \frac{\beta}{2}\sum_{i\in V}|\psi_i|^4$$

ここで $V$ は対角行列（ノードごとの制約）として扱うと実装と証明が揃う。

#### 4.6.3 jiwa-SIF（離散問題）の典型

離散最適化を狙うときは「目的関数＋離散化ペナルティ」を Lonadian にする：

$$\Lambda(u;\lambda) = J_{\mathrm{relax}}(u) + \lambda\,D_{\mathrm{disc}}(u) + R(u)$$

典型：

- $u\in[0,1]^n$
- $D_{\mathrm{disc}}(u)=\sum_i u_i(1-u_i)$（二値へ寄せる）
- $R(u)$ は「形」を入れる正則化（例えば $u^\top L u$）

このとき $\lambda$ のスケジュール（増やし方）は **SimP側の設計変数**であり、SolP側では「ある固定の $\lambda$ に対して降下が成立」など、条件つきの主張として切り出すのが安全。

### 4.7 SimPで何を見れば「安定」か（実験の判定基準）

理論上の $d\Lambda/dt\le 0$ は、実装では離散時間の差分として現れる：

$$\Delta\Lambda_k := \Lambda_{k+1}-\Lambda_k$$

実験では次を最低限記録する：

- $\Lambda_k$（時系列）
- 単調率：$P(\Delta\Lambda_k\le 0)$（「何割のステップで下がったか」）
- 監視量：$\rho_{\max}$、$G_\psi$、$R$（発散/局在/位相飛びの検知）

「単調率が100%」は理想だが、数値誤差や外力があると崩れることがある。
その場合は「どの項が破っているか」を分解して見る（次章で扱う）。

### 4.8 SolPで何を示せば「数学的に正しい」か（証明の型）

「数値で当たりを付けた」後に、SolPで最低限やるべきことは次の順序になる：

1. **設定の明確化**：状態空間、境界条件、$\Lambda$、時間発展（更新則）を固定
2. **下界**：$\Lambda$ が下に有界（もしくはレベル集合が有界）である
3. **降下**：$d\Lambda/dt\le 0$（または離散更新なら $\Delta\Lambda\le 0$）を示す
4. **収束の言い方**：極限点が臨界集合に入る、など適切な形で結論する
5. **離散化の誤差**（必要なら）：連続→離散、緩和→丸め で何がどれだけズレるかを境界づける

このセットが揃うと、SimPで観測した「安定に見える」が「条件つきの数学的主張」として固定され、次の実験の土台になる。

### 4.9 この章の要約（次章への橋）

- Lonadian $\Lambda$ は「値」よりも「降下する向き」が重要（$d\Lambda/dt\le 0$）。
- 実務では「保存項＋降下項」を分けて設計すると、証明と実装が揃う。
- 外力・ノイズ・数値誤差で単調性が崩れるときは、「どの項が破っているか」を分解して扱う必要がある。
  次章ではそのために、境界・ゲージ・保存/散逸の分解を整理する。

## 5. 境界・ゲージ・保存項/散逸項の分解

この章は「なぜ実装で $d\Lambda/dt\le 0$ が崩れるのか」を、原因別に切り分けるための章。
LoNA方程式を「保存/散逸」に分けるだけでなく、**境界**と**ゲージ（対称性）**が混ざると話が壊れやすい。

### 5.1 境界条件：「境界項」が出るかどうか

連続系（C-SIF）では、$\Lambda$ の時間微分を計算するとしばしば「部分積分」が出てくる。
そのとき、典型的に

- 体積項（内部）：負になる（降下に寄与）
- 境界項：符号が自由（境界から入出力があると増える）

に分かれる。

実務上の要点は次の2つ：

1. **閉系にしたいなら境界項を消す**  
   周期境界、Dirichlet、Neumann など「境界での流束が消える」条件を選ぶ。
2. **境界項を残すなら「入力」として扱う**  
   境界は外力 $F$ と同じで、$\Lambda$ を増やし得る。増減の責任を境界へ帰属させる。

> 目標：「閉系」と言うときは「境界項=0」まで含めて閉じる。

### 5.2 ゲージ（対称性）と「同値な状態」

LoNalogyでは、状態に同値性（対称性）がある。
代表例は全体位相の回転：

$$\psi \mapsto e^{i\theta}\psi$$

多くの Lonadian はこの変換で不変（ゲージ不変）になっている。
その場合、「位相回転方向」の運動は「保存項」に分類できる：

$$\partial_t\psi \supset -i\omega_0\psi$$

ここで重要なのは：

- 「保存項」は状態を動かすが、「観測量（特に $\Lambda$）」を動かさないように設計する
- 逆に、「観測量が動く」なら、それは保存項ではなく散逸/外力の一部として扱う

実装のコツ：

- 絶対位相 $S$ を議論したくなる場面は、まず「位相差 $\Delta S$」に落とせないか確認する
- どうしても絶対位相が必要なら、基準（ゲージ固定）を決める  
  例：「平均位相が0」、「特定ノードの位相が0」、など

### 5.3 保存項と散逸項：「Λを変えない」 vs 「Λを下げる」

LoNalogyの基本分解：

$$\partial_t\psi = \mathcal{A}[\psi] + \mathcal{D}[\psi] + F + \xi$$

ここでの分類基準は「$\Lambda$ をどう動かすか」：

- **散逸（降下）**：$\displaystyle \mathcal{D}[\psi] = -\mathcal{G}\frac{\delta\Lambda}{\delta\bar{\psi}}$  
  「閉系」であれば $d\Lambda/dt\le 0$ を保証したい部分。
- **保存（回転）**：$\displaystyle \mathcal{A}$ は「$\Lambda$ を変えない」ように設計する部分。

形式的には、次を満たすとき「保存」と呼べる：

$$\mathrm{Re}\left\langle \frac{\delta\Lambda}{\delta\bar{\psi}},\,\mathcal{A}[\psi]\right\rangle = 0$$

この式は「保存」を判定するためのチェックリストとして使える。

### 5.4 「単調性が崩れた」ときの原因分解

実装で $\Lambda$ が増えるとき、ほぼ原因は次のどれかに分類できる：

1. **境界の入出力**（境界項が消えていない）
2. **外力 $F$ の注入**（意図した入力、または制約項の実装ミス）
3. **ノイズ $\xi$ の注入**（探索を入れた、あるいは乱数のスケールが大きい）
4. **時間離散化誤差**（$dt$ が大きい、積分器が硬さに負けている）
5. **「Λ」の定義が更新則と一致していない**（「降下しているはず」が別の関数を測っている）

このとき便利なのは「エネルギー収支」として書くこと：

$$\frac{d\Lambda}{dt} =
-\left\langle \frac{\delta\Lambda}{\delta\bar{\psi}},\,\mathcal{G}\frac{\delta\Lambda}{\delta\bar{\psi}}\right\rangle
+ \mathrm{Re}\left\langle \frac{\delta\Lambda}{\delta\bar{\psi}},\,\mathcal{A}[\psi]\right\rangle
+ \mathrm{Re}\left\langle \frac{\delta\Lambda}{\delta\bar{\psi}},\,F+\xi\right\rangle
\;+\;(\text{境界項})
$$

閉系の理想では「後ろ3項」が全部 0 になり、「最初の項」だけが残る。

### 5.5 離散（D-SIF）の境界：「ポート」という考え方

グラフでは空間境界の代わりに、「外界と接するノード集合」を **ポート** として定義できる。
例えば $V = P \cup I$（ポート $P$ と内部 $I$）という分割を入れると、

- ポート値を固定する：離散 Dirichlet 条件
- ポートへ入力を入れる：外力 $F$ として扱う

のように整理できる。

この「境界=ポート」の見方は、後の LoNA-Thévenin（部分系圧縮）へ直結する。

### 5.6 実装ガイド：「項ごとに ΔΛ を計測」する

SimPで最短に原因を切り分けるため、更新則を項ごとに分解して「部分更新」を作る：

- $\psi \to \psi^{(A)}$（保存項のみ）
- $\psi^{(A)} \to \psi^{(AD)}$（散逸項を足す）
- 必要なら $F,\xi$ を別ステップで足す

そして

$$\Delta\Lambda_A,\;\Delta\Lambda_D,\;\Delta\Lambda_F,\;\Delta\Lambda_\xi$$

をそれぞれ測る。

この計測ができると、

- 「保存項なのに $\Delta\Lambda_A \ne 0$」 → 設計か実装が破綻している
- 「散逸項なのに $\Delta\Lambda_D > 0$」 → $dt$ 過大、「降下の計量」不整合、境界漏れ

など、問題が一発で特定できる。

### 5.7 この章の要約（次章への橋）

- 「閉系の降下」は、保存/散逸の分解だけでなく「境界項=0」まで含めて成立する。
- 「保存項」は「$\Lambda$ を変えない」ことが定義であり、チェック式 $\mathrm{Re}\langle \delta\Lambda/\delta\bar{\psi},\,\mathcal{A}[\psi]\rangle=0$ が使える。
- 次の Part II では、C-SIF/D-SIF/jiwa-SIF をそれぞれの「世界」として定義し、同じ原理（「降下・境界・対称性」）をどう実装へ落とすかを整理する。

---

# Part II: 3つのSIF系統

## 6. C-SIF（連続場）

この章は「連続空間上の LoNalogy」を定義する。PDE・場の理論・流体・波動などはここに入る。
実装（離散化・積分器）は Part V で扱い、ここでは **モデルの置き方**を固定する。

### 6.1 C-SIFの対象（何を状態として持つか）

C-SIF では、次を与えて「系」を定義する：

- 定義域：$\mathcal{D}\subset\mathbb{R}^d$
- 境界条件：周期 / Dirichlet / Neumann（または混合）
- 状態：$\psi:\mathcal{D}\times\mathbb{R}_+\to\mathbb{C}$
- パラメータ束：$\Theta$
- Lonadian：$\Lambda_C[\psi]$
- 観測量：$\mathcal{H}[\psi]$（第2章）

このセットが揃えば、SimP（数値）と SolP（解析）の両方で同じ対象を語れる。

### 6.2 C-SIFの標準形（LoNA-PDE）

最も汎用の書き方は第3章の標準形：

$$
\partial_t\psi
= (-\gamma - i\omega_0)\psi
+ D\Delta\psi
+ \alpha|\psi|^2\psi
- V(x)\psi
+ F(x,t)
+ \xi(x,t)
$$

ここで「C-SIFとして本質的」なのは、「連続の作用素」（$\Delta$ と境界条件）を通じて
「形」（粗さ・局在・パターン）を制御できる点にある。

### 6.3 LonadianからPDEを作る（設計手順）

**設計の基本手順**は：

1. 「下に有界で、意味のある」 $\Lambda_C[\psi]$ を決める
2. $\delta\Lambda_C/\delta\bar{\psi}$ を計算する
3. 勾配流（＋保存項）として時間発展を定義する

典型の Lonadian：

$$\Lambda_C[\psi] = \int_{\mathcal{D}}\left(D|\nabla\psi|^2 + V(x)|\psi|^2 + \frac{\beta}{2}|\psi|^4\right)\,dx$$

このとき（境界条件が整っていれば）

$$\frac{\delta\Lambda_C}{\delta\bar{\psi}} = -D\Delta\psi + V(x)\psi + \beta|\psi|^2\psi$$

となるので、勾配流

$$\partial_t\psi = -\frac{\delta\Lambda_C}{\delta\bar{\psi}}$$

は

$$\partial_t\psi = D\Delta\psi - V(x)\psi - \beta|\psi|^2\psi$$

を与える。

ここに保存項 $-i\omega_0\psi$ を足すと「回転しながら降下」する系になる。

> 重要：「係数の名前」より「役割」を揃える。  
> 例：$D$ は粗さを削る、$V$ は制約、四乗項は飽和/集束の役割。

### 6.4 「境界」はC-SIFの一部（閉系/開系）

C-SIFで「閉系」を名乗るには、境界条件が $\Lambda$ の降下証明に整合している必要がある（第5章）。

- 周期境界：境界項が消えやすい（スペクトル法とも相性が良い）
- Dirichlet：状態を境界で固定（「外界が強制している」とも読める）
- Neumann：流束ゼロ（「境界を越えて出入りしない」）

境界が入力を持つ場合は、C-SIFではなく「C-SIF + ポート（開系）」として扱う。

### 6.5 C-SIFの読み方：「形」の力学

C-SIFの見方は大きく3層に分けられる：

1. **局所**：$\rho(x), S(x)$ のパターン（渦、壁、局在、波）
2. **中域**：粗さ $G_\psi$、整列 $R$、質量 $M$ などの統計量
3. **大域**：$\Lambda$ の降下、臨界集合への収束、安定/不安定の相図

この3層を「同じログ」として同時に観測できるようにしておくと、SimP↔SolP が回しやすい。

### 6.6 この章の要約（次章への橋）

- C-SIFは「連続世界」で、境界条件込みの作用素（$\Delta$ 等）を核として定義する。
- Lonadian $\Lambda_C$ を先に決めてから、勾配流（＋保存項）でPDEを作るのが最も安定する。
- 次章では、離散世界（D-SIF）で同じ考え（「形」・「降下」・「境界」）をどう持つかを整理する。

## 7. D-SIF（離散グラフ）

この章は「離散世界（グラフ上）の LoNalogy」を定義する。
狙いは2つ：

1. 連続の考え（形・降下・境界）を、グラフ上でも同じ言葉で扱えるようにする
2. jiwa-SIF（離散最適化）へ接続するための「離散側の土台」を作る

### 7.1 D-SIFの対象（何を与えれば系が決まるか）

D-SIFでは、次を与えて「系」を定義する：

- グラフ：$G=(V,E)$（必要なら重み付き）
- 状態：$\psi\in\mathbb{C}^{|V|}$（ノード上の複素状態）
- ラプラシアン：$L$（標準は $L=D_g-A$）
- 境界（ポート）：$P\subset V$（任意、閉系なら空集合でもよい）
- パラメータ束：$\Theta$
- Lonadian：$\Lambda_D(\psi)$
- 観測量：$\mathcal{H}[\psi]$（第2章）

このセットは C-SIF と同型の「定義セット」になっているのが重要。

### 7.2 D-SIFの標準形（LoNA-ODE on Graph）

第3章の典型形を、離散作用素で書く：

$$\dot{\psi} = (-\gamma - i\omega_0)\psi - D L\psi + \alpha\,\operatorname{diag}(|\psi|^2)\psi - V\psi + F + \xi$$

ここでの解釈：

- $-DL\psi$：隣接ノードとの差を縮める（平滑化）
- $V$：ノードごとの制約（対角）
- $\alpha$：ノード内の飽和/集束（必要なら拡張）

> 実装は「まず線形 + 平滑化（$-DL$）だけ」で安定性を確認し、非線形を足していくのが安全。

### 7.3 LonadianからD-SIFを作る（設計手順）

連続と同様、まず $\Lambda_D$ を決める：

$$\Lambda_D(\psi) = D\,\langle \psi, L\psi\rangle + \langle \psi, V\psi\rangle + \frac{\beta}{2}\sum_{i\in V}|\psi_i|^4$$

このとき、勾配流

$$\dot{\psi} = -\frac{\partial \Lambda_D}{\partial \bar{\psi}}$$

は（典型的に）

$$\dot{\psi} = -D L\psi - V\psi - \beta\,|\psi|^2\odot\psi$$

のような形になる（$\odot$ は要素ごとの積）。

ここに保存項 $-i\omega_0\psi$ を足せば、「回転しながら降下」の構造ができる。

### 7.4 「粗さ」= 二次形式：$\langle\psi,L\psi\rangle$

離散で最も重要な置換は

$$\int |\nabla\psi|^2 dx \quad\longleftrightarrow\quad \langle\psi,L\psi\rangle$$

である。さらに

$$\langle\psi,L\psi\rangle = \frac{1}{2}\sum_{(i,j)\in E}w_{ij}\,|\psi_i-\psi_j|^2$$

（重み付きの場合）という等式があり、「なぜ平滑化なのか」が直観的に見える。

ここから得られる実務的含意：

- $L$ が半正定値である限り、$\langle\psi,L\psi\rangle\ge 0$（粗さは非負）
- $-DL\psi$ は「粗さを減らす」方向に働く

### 7.5 D-SIFの境界：ポートと入出力

グラフの「境界」はノード集合 $P\subset V$（ポート）として表す（第5章）。

- ポートを固定：$\psi_P(t)=\psi_P^{\mathrm{given}}$（離散Dirichlet）
- ポートへ入力：$F_P(t)\ne 0$（開系）

内部 $I:=V\setminus P$ は閉じた力学として扱える。
この分割は LoNA-Thévenin（部分系圧縮）へそのまま繋がる。

### 7.6 離散最適化への接続（jiwa-SIFの前段）

離散最適化（B）に寄せたいとき、D-SIFは「グラフ上の緩和変数」の器になる：

- 変数 $u\in[0,1]^{|V|}$ をノードに置く
- 正則化として $u^\top L u$ を入れる（隣接ノードが近い値を取るようにする）

このとき

$$R(u)=u^\top L u$$

は「局所性」や「滑らかさ」を入れるレバーとして機能する。
どの $L$ を使うか（元の問題のグラフ、近傍グラフ、学習されたグラフ）は、SimP側の設計変数になる。

### 7.7 代表的な観測・失敗パターン

最低限、次をログする：

- $\Lambda_D$ と単調率
- $\rho_{\max}$（発散の検知）
- $G_\psi=\langle\psi,L\psi\rangle$（粗さ）
- $R$（整列）

よくある失敗と対処：

- $\Lambda_D$ が増える：$dt$ 過大、境界入力、「Λと更新則の不整合」
- $G_\psi$ が増え続ける：平滑化が弱い（$D$不足）、ノイズ/外力が強い
- $\rho_{\max}$ が暴走：非線形係数の符号/スケール、「下に有界」条件の破れ

### 7.8 この章の要約（次章への橋）

- D-SIFは「グラフ上の連続力学」として定義し、$\langle\psi,L\psi\rangle$ を粗さの基準にする。
- 境界はポート集合で扱い、閉系/開系を明確に分ける。
- 次章の jiwa-SIF では、D-SIFを足場に「離散問題を連続降下で解く」ための関手（連続化/離散化）を定義する。

## 8. jiwa-SIF（離散⟺連続の橋）

この章は LoNalogy を「離散問題（B）」へ拡張するための中心概念である。  
要点は、離散世界（D-SIF）と連続世界（C-SIF）を **関手のペア**で往復し、連続側の「降下（Lyapunov）」を使って離散側の解を作ること。

### 8.1 jiwa-SIFが解く問題

離散問題は一般に

- 変数：$x \in \mathcal{X}$（例：$\{0,1\}^n$、組合せ、ラベル付け）
- 目的関数：$J(x)$
- 制約：$x \in \mathcal{C}$

の形を取る。ここで難しいのは、$\mathcal{X}$ が離散であるため「なめらかな降下」がそのまま使えない点。

jiwa-SIFの戦略は：

1. 離散を連続に持ち上げる（緩和・埋め込み）
2. 連続で Lonadian を下げる（降下）
3. 連続を離散へ戻す（射影・量子化）

という往復で、離散の解候補を作る。

### 8.2 2本の関手：連続化 F と 離散化 G

圏論的に言えば、「世界」を次のように捉える：

- **連続世界** $\mathbf{C}$：C-SIF（連続場）とその構造（作用素、境界、Lonadian、観測）  
- **離散世界** $\mathbf{D}$：D-SIF（グラフ）や離散最適化の構造（変数集合、制約、目的関数、観測）

jiwa-SIFは、この2つの世界を次の関手で繋ぐ：

- **連続化（緩和）**：$F:\mathbf{D}\to\mathbf{C}$
- **離散化（射影）**：$G:\mathbf{C}\to\mathbf{D}$

直感：

- $F$ は「離散問題を、連続のエネルギー（またはPDE/ODE）として表現できる形にする」
- $G$ は「連続の状態を、離散の解（または離散状態）として読み取る」

実務上の要件：

- $F,G$ は **明示**されていること（曖昧な「雰囲気変換」をしない）
- 乱数を使うなら **分布とシード規約**を固定する（再現性のため）

### 8.3 近似随伴：unit/counit を「誤差」として扱う

理想形では $F \dashv G$（随伴）を目指す。  
ただし現実の jiwa では「厳密な随伴」より **近似随伴**（誤差境界つき）として扱う方が安全である。

随伴の観点は、往復の「ズレ」を整理する道具になる：

- **unit**：$\eta: \mathrm{Id}_{\mathbf{D}} \to G\circ F$  
  離散 $d$ を連続化して戻したとき、どれだけ元に戻るか
- **counit**：$\varepsilon: F\circ G \to \mathrm{Id}_{\mathbf{C}}$  
  連続 $c$ を離散化して戻したとき、どれだけ元に戻るか

実務では、「等しい」ではなく次のように読む：

- 状態誤差：$\|\eta(d)-d\|,\;\|\varepsilon(c)-c\|$
- 目的誤差：$|J(d)-J_{\mathrm{relax}}(F(d))|$ など

これにより、SolP側で「どこまでを厳密に保証し、どこからを近似として切るか」が明確になる。

### 8.4 jiwa-SIFのLonadian：目的関数＋離散化ペナルティ

jiwa-SIFでは、連続変数 $u$（または $\psi$ の強度部分）を持ち、
Lonadian を次の分解で設計する：

$$\Lambda(u;\lambda) = J_{\mathrm{relax}}(u) + \lambda\,D_{\mathrm{disc}}(u) + R(u)$$

- $J_{\mathrm{relax}}$：離散目的 $J$ の連続緩和
- $D_{\mathrm{disc}}$：離散性ペナルティ（離散集合へ寄せる）
- $R$：形・局所性・安定性の正則化（必要なときに足す）
- $\lambda\ge 0$：離散性の強さ（スケジュール変数）

二値の場合の典型：

- $u\in[0,1]^n$
- $D_{\mathrm{disc}}(u)=\sum_i u_i(1-u_i)$

このとき、固定 $\lambda$ に対して

$$\dot{u} = -\nabla_u \Lambda(u;\lambda)$$

と置けば、原理的に「降下」を作りやすい（第4章）。

> 注意：$\lambda(t)$ を時間で変えると、厳密な単調性は壊れることがある。  
> 実務では「段階的に $\lambda$ を固定して降下させる」（ステージング）に分けると、証明と実装が揃う。

### 8.5 ステージング：「緩く探して、硬く決める」

離散最適化でよく効くのは次の二段（または多段）戦略：

1. **探索ステージ（小さい $\lambda$）**：$J_{\mathrm{relax}}$ を主に下げ、良い谷（basin）へ入る
2. **離散化ステージ（大きい $\lambda$）**：$D_{\mathrm{disc}}$ を強め、$u$ を頂点（離散解）へ寄せる

各ステージで：

- $\lambda$ を固定
- 降下を回して収束判定（$\Delta\Lambda$、$\|\nabla\Lambda\|$ など）
- $G$ で離散候補 $\hat{x}=G(u)$ を得て、$J(\hat{x})$ を評価
- これまでの最良解を保持

という形にすると、SimP↔SolP が回しやすい。

### 8.6 SolPで狙う証明（jiwa版の最低限セット）

jiwa-SIFで SolP が「最低限」保証したいのは次：

1. 固定 $\lambda$ に対して $\Lambda(u;\lambda)$ が降下する（更新則と整合している）
2. レベル集合の有界性など、発散しない条件を示す
3. 「離散に近い」領域で $G$ が目的関数を大きく壊さないことを境界づける  
   例：$u$ が 0/1 に十分近いなら、丸め誤差で $J$ が増えすぎない

これにより「数値で当たりを付けた操作（スケジュールや丸め）」が、
条件つきで数学的な主張に固定され、次の証明の部品になる。

### 8.7 SimPで探る領域（jiwa版の自由度）

一方で SimP 側が探索してよい自由度は、明確に「設計変数」として扱う：

- 緩和の設計：$J_{\mathrm{relax}}$ の選び方
- 正則化：$R(u)$ の形（例：$u^\top L u$）
- ステージング：$\lambda$ の段数、値、順序
- 離散化 $G$：閾値、タイブレーク、制約修復（repair）

SimPで有望な組を見つけ、SolPで「何が保証できるか」を切り出す、が jiwa の基本回し方になる。

### 8.8 この章の要約（次章への橋）

- jiwa-SIFは $F:\mathbf{D}\to\mathbf{C}$ と $G:\mathbf{C}\to\mathbf{D}$ の往復で、離散問題を連続降下へ持ち込む。
- unit/counit を「往復誤差」として整理すると、証明すべきポイントが見える。
- 次の Part III では、「境界（ポート）」の視点から内部自由度を消す LoNA-Thévenin（Schur補完）を扱う。

---

# Part III: 圧縮と等価化

## 9. LoNA-Thévenin（Schur補完による部分系圧縮）

この章は「巨大な内部自由度を消して、境界（ポート）だけの理論に落とす」ための章。
LoNalogyではこの操作を LoNA-Thévenin と呼び、回路理論のテブナン等価・制御のモデル縮約・PDEのDirichlet-to-Neumann（DtN）を同じ枠で扱う。

### 9.1 目的：内部を消して境界応答だけ残す

扱いたい状況：

- 系は大きい（ノード数が多い、連続なら自由度が巨大）
- しかし観測/制御したいのは境界（ポート）だけ

このとき、内部をそのまま解く代わりに

> 「ポート入力 → ポート出力」  
> だけを記述する **有効作用素** に縮約する

のが LoNA-Thévenin の目的。

### 9.2 D-SIF（有限次元）での基本：Schur補完

最も分かりやすいのは離散（有限次元）である。
ノードをポート $P$ と内部 $I$ に分割し、状態も

$$\psi=\begin{pmatrix}\psi_P\\\psi_I\end{pmatrix}$$

のように分ける。

線形化された力学（またはラプラス領域）では、行列（作用素）をブロック分割できる：

$$A=\begin{pmatrix}
A_{PP} & A_{PI}\\
A_{IP} & A_{II}
\end{pmatrix}$$

このとき、内部を消したポート有効作用素は Schur補完で与えられる：

$$Z_{\mathrm{eff}}(s)=sI-A_{PP}-A_{PI}(sI-A_{II})^{-1}A_{IP}$$

ここで $s=\sigma+i\omega$ はラプラス変数で、$Z_{\mathrm{eff}}$ は多ポートの「有効インピーダンス」に対応する。

> ポイント：「Schur補完」は線形代数の標準操作であり、LoNalogyの新規性は「それを何に適用するか」と「どの観測量に落とすか」にある。

### 9.3 何が嬉しいか：計算量と解釈

Schur補完で得られる利点は2つ：

1. **計算量の削減**  
   内部自由度を直接追う代わりに、ポート次元の問題に落とす。
2. **物理的解釈**  
   $Z_{\mathrm{eff}}(s)$ を見るだけで「共鳴・減衰・結合の強さ」が分かる。

特に LoNalogy の運用では、SimPで大規模系を走らせてから
SolPで「なぜその応答になるか」を解析したいので、
「観測すべき量」が $Z_{\mathrm{eff}}$ のように縮約されているのは大きい。

### 9.4 非線形・時間依存への拡張：凍結線形化

多くの現実問題は非線形である。そこで LoNalogy では次の近似を使う：

1. 時刻 $t$ で系を **凍結線形化**する（ヤコビアンを取る）
2. その線形化作用素に Schur補完を適用し、$Z_{\mathrm{eff}}(t,s)$ を得る
3. 時刻を進めて繰り返す

このとき $Z_{\mathrm{eff}}$ は時間依存になり、
「相転移や状態変化を境界応答だけで追う」という読み方が可能になる。

> 注意：凍結線形化は標準技法だが、「境界だけを追う」順序にすることで、巨大系を扱いやすくなる。

### 9.5 LoNalogyでの使い方：「ポートを決める」が全て

縮約が効くかどうかは、ポート設計に強く依存する。
実務上のチェック：

- ポートは観測/制御したい変数を含んでいるか
- 内部は本当に「消してよい」自由度か（欲しい情報が内部に残っていないか）
- Schur補完に必要な逆行列 $(sI-A_{II})^{-1}$ が安定に計算できるか

ポートを決めたら、あとは

1. 線形化（または線形モデル化）
2. ブロック分割
3. Schur補完
4. $Z_{\mathrm{eff}}$ の観測・比較

の流れになる。

### 9.6 この章の要約（次章への橋）

- LoNA-Théveninは、内部自由度をSchur補完で消してポート応答 $Z_{\mathrm{eff}}$ に縮約する枠組み。
- 非線形でも凍結線形化で逐次的に $Z_{\mathrm{eff}}(t,s)$ を追える。
- 次章では、この縮約が連続世界（PDE）では Dirichlet-to-Neumann（DtN）として現れることを整理する。

## 10. Dirichlet-to-Neumann / 多ポート / 有効インピーダンス

この章は第9章の「有限次元（D-SIF）でのSchur補完」が、
連続世界（C-SIF）の境界値問題では **Dirichlet-to-Neumann（DtN）作用素**として現れることを整理する。

結論だけ言うと：

- D-SIF：内部消去 = Schur補完
- C-SIF：内部消去 = DtN（境界データから境界流束を返す作用素）

であり、LoNalogyの「ポート応答」概念は連続/離散で同じ形になる。

### 10.1 Dirichlet-to-Neumann（DtN）の直感

境界値問題では、境界で

- Dirichletデータ：値（状態）を与える
- Neumannデータ：法線方向の微分（流束）を読む

という2種類が自然に出る。

DtN作用素は

> 境界の値（Dirichlet）を与えると、境界の流束（Neumann）を返す

という写像であり、内部を全部解いた結果だけを境界に凝縮している。

### 10.2 ポートの多次元化：「1点」ではなく「境界空間」

回路の「多ポート」は、連続では「境界上の関数空間」に対応する。

- 離散：$\psi_P\in\mathbb{C}^{m}$（ポートノードが $m$ 個）
- 連続：$\psi|_{\partial\mathcal{D}} \in \mathcal{P}$（境界上の関数空間）

ここで $\mathcal{P}$ は、例えば $L^2(\partial\mathcal{D})$ のような空間になる。

従って $Z_{\mathrm{eff}}$ も、連続では

$$Z_{\mathrm{eff}}:\mathcal{P}\to\mathcal{P}$$

という「作用素」になる。

### 10.3 線形PDEでの縮約：「内部を解いて境界だけ残す」

線形（凍結線形化後を含む）な設定で、内部を $A$ とみなすとき、
離散と同様に

- 内部自由度を解く
- 境界に代入する

という操作で境界作用素が得られる。

形式的には第9章の無限次元版として

$$Z_{\mathrm{eff}}(s) = P(sI-A)P - PAQ(sI-QAQ)^{-1}QAP$$

のような式が現れる（$P$ はポート射影、$Q$ は内部射影）。

ここで

- $P$ が境界（ポート）への射影
- $(sI-QAQ)^{-1}$ が内部の解（グリーン関数/ resolvent）

に対応している。

### 10.4 有効インピーダンスとしての読み方

LoNalogyの文脈では、$Z_{\mathrm{eff}}$ を次のように読むと実務に効く：

- $\|Z_{\mathrm{eff}}(i\omega)\|$：境界入力に対する応答の大きさ
- $Z_{\mathrm{eff}}$ の極/零点：共鳴・減衰・モードの現れ
- 時間依存 $Z_{\mathrm{eff}}(t,i\omega)$：相転移・状態変化の追跡

重要なのは「内部の全状態」を保持しなくても、境界応答だけで現象を追えること。

### 10.5 実装への落とし方：連続でも最終的に「離散化」する

連続のDtNは厳密には無限次元だが、計算では必ず離散化する。
すると DtN は「大きな行列」になり、結果として第9章の Schur補完と同じ構造になる。

実務の流れ：

1. 境界（ポート）を決める（どの境界量を観測/制御したいか）
2. 離散化して線形系（または線形化系）を作る
3. 内部自由度を消して $Z_{\mathrm{eff}}$ を計算する
4. $Z_{\mathrm{eff}}$ の時間/周波数依存を観測する

ここでのポイントは、「どの離散化」よりも
「ポートをどう切ったか」が支配的なことが多い。

### 10.6 この章の要約（次章への橋）

- Schur補完（離散）とDtN（連続）は、どちらも「内部を消して境界応答だけ残す」同じ操作。
- LoNalogyでは、境界（ポート）を中心に据えることで巨大系を扱える。
- 次の Part IV では、パラメータ束 $\Theta$ 自体が動く Meta 層（自己調整）を定義する。

---

# Part IV: Meta層（自己調整）

## 11. 5階層（Level 0–4）と Meta-LoNA

この章は LoNalogy を「単一の方程式」ではなく、**複数の時間スケールを持つ運用システム**として定義する。
ポイントは、「状態」と「パラメータ」を同じレイヤーで更新しないこと。
状態 $\psi$ が落ち着く前に $\Theta$ を動かすと、系は簡単に暴走する。

### 11.1 なぜ階層が必要か

実務上よく起きる問題：

- パラメータを適当に動かすと「収束したように見える」が、条件が変わると崩れる
- 安定性（$d\Lambda/dt\le 0$）を満たしたいのに、外側ループがそれを破る

これを防ぐため、LoNalogyは「動かす対象」を階層に分ける。

### 11.2 5階層（Level 0–4）

本書では次の5階層を基本にする：

#### Level 0：基本動力学（状態の時間発展）

状態 $\psi$ を時間 $t$ で進める層：

$$\partial_t\psi = \mathcal{L}[\psi;\Theta] + \xi$$

ここでの主目的は「閉系の降下」（$d\Lambda/dt\le 0$）を成立させること。

#### Level 1：Meta-LoNA（パラメータ進化）

パラメータ束 $\Theta$ を遅い時間 $\tau$ で進める層：

$$\partial_\tau \Theta = \mathcal{F}[\Theta,\mathcal{H}[\psi]]$$

直感：「実験で観測した統計量」（$\mathcal{H}[\psi]$）を使って、
$\Theta$ を安全に自己調整する。

#### Level 2：Meta\u00b2（Lonadianの形の進化）

Lonadian の「重み」や形状パラメータ $\theta_\Lambda$ をさらに遅い時間で進める：

$$\partial_{\tau_2}\theta_\Lambda = \mathcal{G}[\theta_\Lambda,\text{performance}]$$

ここでの主目的は「何をエネルギーとして見るべきか」を学習/選択すること。

#### Level 3：Meta\u00b3（SimP↔SolP 循環）

数値実験（SimP）と解析（SolP）を往復し、定理・補題・反例を生成する層。
この層は「時間発展」というより「研究プロセス」のループである。

#### Level 4：Meta\u2074（関手選択・世界の切替）

証明や設計が詰まったとき、どの世界（圏）で考えるかを切り替える層：

- C-SIF（連続） ↔ D-SIF（離散） ↔ jiwa-SIF（最適化）
- （必要なら）他の世界を追加していく

この層は概念設計として置き、まずは Level 0–3 の運用を固めるのが現実的。

### 11.3 時間スケール分離（運用ルール）

階層を実際に動かす上での最低限ルール：

- **Level 0 を十分回してから Level 1 を1回更新する**  
  例：「内側1000ステップ → 外側1ステップ」
- **Level 1 を十分回してから Level 2 を動かす**
- Level 3 は「節目」（実験が揃ったとき）に回す

形式的には

$$t \ll \tau \ll \tau_2$$

の分離を保つ。

### 11.4 Meta-LoNAの安全設計（次章への接続）

Level 1 の更新則 $\partial_\tau\Theta=\mathcal{F}[\Theta,\mathcal{H}[\psi]]$ は強力だが危険でもある。
次章では、この危険を抑えるための

- 安全域（クリップ）
- 射影（投影）
- 「降下を壊さない」更新

を設計原理としてまとめる。

### 11.5 この章の要約（次章への橋）

- LoNalogyは「状態」と「パラメータ」を別時間スケールで動かす階層構造を持つ。
- Level 0（降下）→ Level 1（自己調整）→ Level 3（SimP↔SolP）という順序で運用を固めるのが実務的。
- 次章では、Meta更新が暴走しないための「安全域・射影・制御」を定義する。

## 12. 安全域・射影・制御としてのLoNalogy

この章は Meta-LoNA（Level 1）が暴走しないための「安全設計」をまとめる。
「パラメータも力学である」以上、「更新則そのもの」に安全機構を入れる必要がある。

### 12.1 なぜ安全域が必要か

Meta更新は、少数の観測量 $\mathcal{H}[\psi]$ を見て $\Theta$ を動かす。
そのため、次のどれかが起きると簡単に破綻する：

- 観測量がノイズで揺れる（推定誤差）
- ある領域でモデルが不適切（仮定違反）
- 更新幅が大きすぎる（制御として不安定）

従って「この範囲にいれば安全」という箱（安全域）を先に決める。

### 12.2 安全域 $\mathcal{S}$ と射影 $\Pi_{\mathcal{S}}$

パラメータ束 $\Theta$ に対し、安全域を

$$\mathcal{S}=\{\Theta \mid \theta_i^{\min}\le \theta_i \le \theta_i^{\max}\}$$

のような直方体（クリップ）として定義する。

そして更新後に必ず射影する：

$$\Theta^{+}=\Pi_{\mathcal{S}}(\Theta+\Delta\Theta)$$

ここで $\Pi_{\mathcal{S}}$ は要素ごとの clip に相当する。

ポイント：

- 「正しさ」のためではなく「壊さない」ための設計
- 解析（SolP）でも「この範囲にいる限り」という条件で定理が言える

### 12.3 安全域の設計原則（最小版）

安全域の下限・上限は「問題ごと」に違うが、原理だけは共通化できる。

1. **物理的に不自然な領域を切る**  
   例：散逸係数が負（「エネルギーが勝手に増える」）など。
2. **数値が壊れる領域を切る**  
   例：$dt$ と相性が悪い硬い領域、発散が起きる領域。
3. **「降下」の前提が壊れる領域を切る**  
   例：「下に有界」が失われる符号やスケール。

この3つを満たす範囲をまず「保守的」に取る。

### 12.4 更新則は制御：「小さく動かす」が基本

Meta更新は制御であり、基本は

$$\Theta_{k+1} = \Pi_{\mathcal{S}}\bigl(\Theta_k + \eta\,U(\mathcal{H}_k)\bigr)$$

のような「小さなステップ」で行う。

- $\eta$：学習率（ゲイン）
- $U(\mathcal{H})$：観測量から作る更新方向

実務のルール：

- まず $\eta$ を小さくして「壊れない」ことを確認
- 速さが必要なら「段階的に」上げる

### 12.5 「降下を壊さない」更新の考え方

理想は「内側（Level 0）の $\Lambda$ 降下を、外側が邪魔しない」こと。
そのために、Meta更新を次の形式に寄せる：

1. **ステージング**：$\Theta$ を固定して十分に「落ち着かせる」（第11章）
2. **更新後に再び落ち着かせる**

つまり

$$\text{(固定 }\Theta\text{ で収束)} \;\to\; \Theta\text{ を少し更新} \;\to\; \text{(再収束)}$$

の反復にする。

このとき SolP 側では

- 固定 $\Theta$ での降下（第4章）
- 「更新幅が小さい」ときに何が保たれるか（連続依存性）

を組み合わせて主張を作る。

### 12.6 実験（SimP）での安全チェック項目

Meta更新を入れた実験では、最低限次をログする：

- $\Theta_k$（時系列）
- 各ステージでの $\Lambda$ と単調率
- 監視量：$\rho_{\max}$、$G_\psi$、$R$

異常検知の典型パターン：

- $\Theta$ が安全域の端に貼り付く：更新方向が偏っている、観測が歪んでいる
- 「更新した瞬間」に $\Lambda$ が跳ね上がる：更新幅が大きい、境界入力が混ざっている
- 単調率が落ちる：積分器/離散化、または「外力相当」の項が混入

### 12.7 この章の要約（次章への橋）

- Meta更新は制御なので、安全域と射影（clip）を基本装備にする。
- 「小さく動かして、十分に収束させる」という運用が、SimP↔SolP を破綻させにくい。
- 次の Part V では、この理論を実装に落とすための数値離散化と時間積分を整理する。

---

# Part V: 計算手法（実装）

## 13. 数値離散化と時間積分（C-SIF/D-SIF共通）

この章は「LoNA方程式を実際に計算できる形に落とす」ための共通ルールをまとめる。
特に LoNalogy では **$d\Lambda/dt\le 0$（降下）**を重要視するため、
数値法は「速い」よりもまず「壊れない」「$\Lambda$ の解釈が崩れない」を優先する。

### 13.1 離散時間：連続の式を「更新則」として書く

連続時間の式

$$\partial_t\psi = \mathcal{L}[\psi]$$

を、離散時間（ステップ $k$）では

$$\psi^{k+1} = \psi^{k} + \Delta t\,\Phi(\psi^k;\Delta t)$$

の形にする（$\Phi$ は数値スキームによる）。

ここでの実務的な考え方：

- 数値計算で本当に扱っているのは「微分方程式」ではなく「更新則」
- SolP で証明する対象も、必要なら **更新則**にする（連続の極限に頼りすぎない）

### 13.2 硬さ（stiffness）と「時間刻みの破綻」

拡散（$D\Delta$）や平滑化（$-DL$）は典型的に硬い。
そのため、陽的（explicit）な更新は「$\Delta t$ の上限」を持つ。

#### 13.2.1 離散（D-SIF）の線形平滑化

線形部分だけ抜き出す：

$$\dot{\psi} = -D L\psi$$

陽的Euler

$$\psi^{k+1} = \psi^k - \Delta t\,D L\psi^k$$

は、ざっくり

$$\Delta t \;\lesssim\; \frac{2}{D\,\lambda_{\max}(L)}$$

を超えると不安定になりやすい（$\lambda_{\max}$ は最大固有値）。

#### 13.2.2 連続（C-SIF）の拡散

拡散を格子で離散化すると、最小スケール（格子幅 $\Delta x$）が硬さを決める。
陽的な拡散更新は一般に

$$\Delta t \;\lesssim\; c\,\frac{\Delta x^2}{D}$$

の制約を持つ（$c$ は離散化や次元で変わる定数）。

> 結論：平滑化が強い（$D$ が大きい）ほど、陽的更新は刻みが極端に小さくなる。

### 13.3 「降下」を保つ数値法：勾配流は「近接（prox）」が相性良い

LoNalogyの核が勾配流

$$\partial_t\psi = -\frac{\delta\Lambda}{\delta\bar{\psi}}$$

であるとき、数値法も「$\Lambda$ が下がる」形に寄せると運用が安定する。

#### 13.3.1 陽的（explicit）勾配降下

$$\psi^{k+1} = \psi^k - \Delta t\,\frac{\delta\Lambda}{\delta\bar{\psi}}(\psi^k)$$

は最も簡単だが、$\Delta t$ が大きいと「$\Lambda$ が増える」ことが普通に起きる。
実務では次のどれかで補強する：

- $\Delta t$ を小さくする
- line search（$\Lambda$ が下がるまで $\Delta t$ を縮める）
- 「硬い部分」を陰的にする（半陰的）

#### 13.3.2 陰的（implicit）Euler と近接更新（prox）

陰的Eulerは

$$\psi^{k+1} = \psi^k - \Delta t\,\frac{\delta\Lambda}{\delta\bar{\psi}}(\psi^{k+1})$$

で、これを「最小化問題」として書くと

$$
\psi^{k+1}
= \arg\min_{\psi}\left\{
\frac{1}{2\Delta t}\|\psi-\psi^k\|_2^2 + \Lambda(\psi)
\right\}
$$

になる（近接点 / proximal step）。

この形の利点：

- 「一歩ごとに」 $\Lambda$ を下げやすい（運用が壊れにくい）
- 硬い項に強い（$\Delta t$ を大きくしても破綻しにくい）

欠点：

- 「毎ステップ最小化」が必要（計算コストが上がる）

> 実務では「平滑化（線形）を陰的、非線形を陽的」など、妥協点を作る（次節）。

### 13.4 線形/非線形の分割（splitting）と「壊れにくさ」

LoNA方程式はしばしば

$$\partial_t\psi = \underbrace{\mathcal{A}[\psi]}_{\text{保存}} + \underbrace{\mathcal{D}[\psi]}_{\text{降下}}$$

に分かれる（第5章）。

実装では分割統治が効く：

1. 保存ステップ（A）：位相回転など、「単位的」な更新で行う  
   例：$\psi \leftarrow e^{-i\omega_0\Delta t}\psi$
2. 降下ステップ（D）：勾配降下、近接、陰的拡散などで行う

この順序で「項ごとの $\Delta\Lambda$」を測ると、単調性が崩れた原因が即座に分かる（第5章）。

### 13.5 C-SIFの空間離散化：「境界条件」と「作用素」を揃える

C-SIFでは、時間以前に「空間の離散化」が必要になる。
原則は：

- 先に「境界条件」を固定する（閉系/開系の定義そのもの）
- その境界条件と整合する形で $\Delta$（ラプラシアン）を離散化する

代表的な手段は複数あるが、本書では「方式の優劣」より次を優先する：

1. 離散化した作用素が「半正定値」（または期待するスペクトル構造）を保つ
2. $\Lambda$ の定義と「同じ離散化」を使う（「測っているエネルギー」と「下げている方向」を一致させる）

### 13.6 D-SIFの空間：「離散化済み」だからこそ「スケール」を決める

D-SIFは空間が最初から離散だが、「スケール」は自動では決まらない。
どのグラフを使うか（重み、近傍、正規化）は、実質的に「離散化の設計」である。

実務のチェック：

- $L$ のスペクトル（$\lambda_{\max}$、スペクトルギャップ）が極端でないか
- $u^\top L u$（または $\langle\psi,L\psi\rangle$）が「望む粗さ」の尺度になっているか

### 13.7 実験ログとして最低限残すもの（数値法の品質）

数値法が正しいかは、「出力画像」ではなく「収支」で判断する。
最低限、次をログに残す：

- $\Lambda_k$ と $\Delta\Lambda_k$
- 単調率 $P(\Delta\Lambda_k\le 0)$
- 監視量：$\rho_{\max}$、$G_\psi$、$R$
- 「項ごとの」 $\Delta\Lambda$（可能なら：保存/降下/外力/ノイズ）

ここまで揃うと、SolP側で「どの仮定が必要か」を切り出しやすい。

### 13.8 この章の要約（次章への橋）

- LoNalogyの数値計算は「更新則」であり、必要なら更新則自体をSolPの対象にする。
- 平滑化は硬いので、陽的更新は $\Delta t$ 制約を持つ。壊れやすいときは陰的/近接に寄せる。
- 「測る $\Lambda$」と「下げる更新」の離散化を一致させるのが最重要。
- 次章では、実装上の具体（CPU/GPU、ライブラリ、観測API、ログ設計）を「公開可能な形」で整理する。

## 14. 実装ガイド（CPU/GPU、JAX、観測API、ログ）

（公開可能な形で）LoNalogy の実装を「迷わず同じ実験を再現できる」形に整理する。
この章は特定のマシンや接続手順には触れず、**実装構造**と**観測・ログ設計**に集中する。

### 14.1 最小構成：`step` と `observe` を分離する

実装は次の2関数が分かれていれば崩れにくい：

- `step(psi, params, dt) -> psi_next`：更新則（第13章）
- `observe(psi, params) -> metrics`：観測API（第2章・第4章）

理由：

- SolP は「どの更新則を証明したいか」を固定して議論できる
- SimP は「何を見て判断したか」がログから復元できる
- 更新則を変えても観測量が共通なら比較できる

### 14.2 状態表現：複素 $\psi$ をそのまま持つか、実部/虚部に割るか

- 複素配列として持つ：実装が短い、式が自然
- 実部/虚部に割る：自動微分・最適化ライブラリの規約差を吸収しやすい

原則は「**$\Lambda(\psi)$ を実数として定義する**」こと。
複素をそのまま使う場合でも、実装では常に `real(...)` を挟んで実数化を保証する。

### 14.3 CPU/GPU：まず「壊れない」設定を決める

実務で効く順番：

1. **精度**：`complex64/float32` で壊れるなら `complex128/float64` へ（硬い項があるほど効く）
2. **刻み**：$\Delta t$ を小さくして第4章の降下が見える領域を先に確保（第13章）
3. **正規化**：$\|\psi\|_2$、$\rho$ のクリップ、境界条件など「安全域」（第12章）を実装に入れる

GPU は速いが、数値誤差と非決定性で「降下が見えにくい」ことがある。
最初は CPU で挙動を固め、次に GPU でスケールさせるのが安定。

### 14.4 JAX での実装の要点（公開版）

JAX で LoNalogy を回すときの要点は「純関数」と「観測の一貫性」：

- `step` と `observe` を **純関数**に寄せる（外部状態に依存しない）
- `step` を `jit` する場合、ログ出力は `observe` でまとめて行い、値（配列）として返す
- `vmap`（並列初期値）で SimP の探索を回し、最後に良いものだけ詳細ログを取る

複素自動微分はライブラリの規約差が出やすいので、以下のどちらかに寄せる：

1. **実部/虚部に分解**して実変数として `grad` を取る  
2. 複素のまま使う場合は、**有限差分で勾配の向き**（$\Delta\Lambda \le 0$ になる向き）を必ず検証する

### 14.5 観測API：最小のメトリクスセット

`observe` が最低限返すべきメトリクス（例）：

- $\Lambda(\psi)$ と $\Delta\Lambda$（第4章）
- 強度：$\rho_{\min},\rho_{\max}$、必要なら $\|\rho\|_1,\|\rho\|_2$
- 粗さ（平滑化の尺度）：$G_\psi := \langle \psi, L\psi\rangle$（離散）または $\langle\nabla\psi,\nabla\psi\rangle$（連続）
- 位相の揺れ：$\|\nabla S\|$ やエッジ差分（必要なら）
- 収束の指標：$\|\psi^{k+1}-\psi^k\|_2$、$\|\nabla\Lambda\|$（計算できるなら）

ここで重要なのは「たくさん測る」よりも、**SolP で条件に落とせる量を固定**すること。

### 14.6 ログ設計：SimP↔SolP の往復に必要なもの

ログは「可視化」ではなく「証明への圧縮」を目的にする（第13章）。
最低限のセット：

- 実験設定：$\Delta t$、ステップ数、乱数種、初期条件の生成法、$\Lambda$ の定義（バージョン付き）
- 計算環境：使用ライブラリの版、dtype、デバイス種別（CPU/GPU）
- 時系列：$\Lambda_k,\Delta\Lambda_k$、単調率 $P(\Delta\Lambda_k\le 0)$、監視量（$\rho_{\max},G_\psi,R$）
- 可能なら：**項ごとの** $\Delta\Lambda$（保存/降下/外力/ノイズ）

公開物に残すログには、**接続情報・鍵・個人識別子・トークン等を含めない**。
必要なら公開用（式・手順・設定）と非公開用（運用メモ）を分ける（第17章）。

### 14.7 「壊れた」ときの最短デバッグ

症状→原因候補→対策の順に切る：

- $\Lambda$ が上がる：$\Delta t$ 過大、境界が開系になっている、符号ミス、勾配規約のズレ
- 途中で発散：硬い線形項（$DL$ や $D\Delta$）を陰的/半陰的へ、dtype を上げる
- 収束が遅い：スケール（$L$ の正規化、係数）と安全域（第12章）の見直し、ステージング（第11章）

「項ごとの $\Delta\Lambda$」を取れる設計にしておくと、原因切り分けが一気に速くなる（第5章・第13章）。

### 14.8 この章の要約（次章への橋）

- 実装は `step`（更新）と `observe`（観測）を分離すると、SimP↔SolP の往復が成立しやすい。
- 最初は CPU で降下が見える領域を固め、次に GPU/JAX でスケールさせる。
- ログは「画像」ではなく「収支」で残す：$\Lambda,\Delta\Lambda$ と監視量、可能なら項別 $\Delta\Lambda$。

---

# Part VI: 検証プロトコル（SimP/SolP）

## 15. SimPループ（実験の標準手順）

SimP は「数値で確かめる」だけでなく、**SolP に渡す“証明可能な形の仮説”を作る工程**である。
この章では、SimP を研究手順として壊れにくい形に固定する。

### 15.1 SimPの目的（SolPのための出力を定義する）

SimP のゴールは次の3点：

1. **降下が見える領域の特定**  
   例：$\Delta t$、散逸係数、正規化の範囲で $P(\Delta\Lambda\le 0)$ が高い領域を見つける。
2. **本質的な観測量の確定**  
   例：$\Lambda$、$G_\psi$、$R$、制約違反量など（第2章・第14章）。
3. **候補定理（SolPカード）の作成**  
   「この条件ならこうなる」を条件つきで言える形に圧縮する（15.4）。

### 15.2 SimPループ（標準形）

最小のループは次：

1. 問題定義：状態 $\psi$、制約、目的（何を「解けた」と見るか）
2. 世界の選択：C-SIF / D-SIF / jiwa-SIF（第6–8章）
3. Lonadian 設計：$\Lambda$ と安全域（第4章・第12章）
4. 更新則：`step` を決める（第13–14章）
5. 観測：`observe` を固定し、ログ形式を決める（第2章・第14章）
6. ベースライン：小さい $\Delta t$・ノイズ無し・閉系から始める
7. 探索（sweep）：$\Delta t$、係数、初期条件、離散化、境界を振る
8. まとめ：SolPカードを吐く（15.4）

### 15.3 Sweepの作法：何を変えて、何を固定するか

SimP で危険なのは「条件が動いているのに、同じ現象だと思い込む」こと。
以下の順に固定していく：

- **(A) まず固定**：$\Lambda$ の定義、境界（閉系/開系）、安全域（射影の有無）
- **(B) 次に振る**：$\Delta t$、散逸係数、正規化の強さ、初期条件
- **(C) 最後に振る**：離散化（格子/有限要素/グラフ構成）、縮約（port/Schur）

観測は「増やす」より先に「同じ計器で測る」を優先する。

### 15.4 SolPカード（SimPの成果を“証明可能な形”に圧縮する）

SimP の出力は、次のテンプレにまとめると SolP に渡しやすい：

- **主張（候補定理）**：何が成立してほしいか（例：$\Lambda$ 単調、収束、誤差上界）
- **条件（候補仮定）**：境界条件、係数の範囲、$\Delta t$ 上限、正規化、$\rho$ の下限など
- **数値証拠**：単調率、収束指標、破綻境界（しきい値）
- **ヒント（カンニング値）**：定数・指数・スケール（例：$\Delta t_{\max}\approx c/(D\lambda_{\max})$）
- **反例メモ**：どの変更で崩れたか（境界、ノイズ、離散化、正規化）

このカードが増えるほど、SolP は「既知の補題の組み合わせ」で回せるようになる。

### 15.5 よくある失敗パターン（SimP側）

- $\Lambda$ が下がっている“つもり”：観測している $\Lambda$ と更新則が対応していない（第13章）
- 収束した“ように見える”：$\Lambda$ は下がるが制約違反が残る（$\Lambda$ の設計不足）
- たまたま収束：初期条件・乱数種に依存して再現しない（ログ不足）

対策は「安全域を入れて小さく動かす」「項別 $\Delta\Lambda$ を測る」「SolPカードに落とす」の3つ。

## 16. SimP↔SolP（数値↔証明の往復）

ここが LoNalogy の中核的な研究エンジン。
やりたいことは単純で、**数値で見えた“当たり”を、解析で正しい命題に直す**。

### 16.1 基本思想：「まず当てる（SimP）、あとで正す（SolP）」

多くの証明は、最初から定数も指数も分からない。
SimP はその部分を「カンニング」して、SolP を前に進める。

重要：SimP の当たりは定理ではなく仮説であり、SolP は「仮説を最小条件に削る」工程である。

### 16.2 SolPのテンプレ：何を証明するかを分解する

SolP は次の分解で進めると破綻しにくい：

1. **降下（Lyapunov）**：$\Lambda_{k+1}\le \Lambda_k$（または期待値で減少）
2. **有界性**：$\{\psi^k\}$ が安全域に留まる（第12章）
3. **収束**：$\sum_k \|\psi^{k+1}-\psi^k\|^2 < \infty$ などから停留点へ
4. **最適性**：停留点が何を意味するか（制約つき、局所、誤差つき）

SimP は 1 と 2 の“壊れる境界”を先に測り、SolP はそこを仮定として明示しながら条件を削る。

### 16.3 典型例：実験で見えた $\Delta t_{\max}$ を解析で証明する

最もよくある流れ（狙いに近い）：

- SimP：ある更新則で「この $\Delta t$ までは降下しそう」が見える  
  例：$\Delta t_{\max}\approx 2/(D\lambda_{\max}(L))$
- SolP：$\lambda_{\max}(L)$ の上界や Lipschitz 定数の評価で、同じ形の条件を証明する

例えば、実数値の目的関数 $\Lambda$ に対する陽的勾配降下

$$\psi^{k+1}=\psi^k-\Delta t\,\nabla\Lambda(\psi^k)$$

で、$\nabla\Lambda$ が $L$-Lipschitz なら

$$
\Lambda(\psi^{k+1})
\le
\Lambda(\psi^k)
-\left(1-\frac{L\Delta t}{2}\right)\Delta t\,\|\nabla\Lambda(\psi^k)\|_2^2
$$

が言え、$\Delta t\le 2/L$ で単調降下が出る。
SimP は「$L$ がどのくらいか」を当て、SolP は「$L$ をどう上から抑えるか」を詰める。

### 16.4 jiwa-SIFの使い方：離散↔連続で“証明しやすい側”へ逃がす

離散問題（D-SIF）で直接証明が重いときは、jiwa の考え方で逃げる：

- **D→C（離散→連続）**：離散を連続に緩和して、解析（エネルギー法、PDE推定）を使う
- **C→D（連続→離散）**：連続の構造を保った離散化を選び、誤差項として戻す

この往復は完全な同値ではなく、往復誤差（round-trip error）が出るのが普通。
SolP では、その誤差を「追加の外力項」または「追加の緩和項」として扱い、降下がどこまで残るかを評価する。

### 16.5 “再帰”の意味：補題のライブラリ化

SimP↔SolP を回すほど、次が資産になる：

- 作用素の評価（$\lambda_{\max}$、ギャップ、コーシー不等式）
- 境界項の見積もり（第5章）
- 射影（クリップ）が入った更新則の解析（第12章）
- 近接/半陰的法の降下保証（第13章）

この補題が増えると、新しい問題でも「実験で当てる→補題の組み合わせで証明」が速くなる。

## 17. 再現性（成果物・記録・公開/非公開の境界）

再現性は「他人のため」だけではなく、**自分が数週間後に続きを書けるため**の設計である。
LoNalogy の再現性は特に、SimP↔SolP 往復の前提になる。

### 17.1 再現性の単位：Run / Study / Library

- **Run**：1回の実験（ある設定での時系列ログ）
- **Study**：複数 Run の比較（sweep、アブレーション、反例収集）
- **Library**：SolP で確定した補題・評価の蓄積（再利用可能な証明部品）

Run を再現できないと Study が崩れ、Study が崩れると SolP の仮定が揺れる。

### 17.2 公開/非公開の境界（重要）

公開してよい（原則）：

- 数式（$\Lambda$、更新則、観測量の定義）
- 実験手順（SimPループ、sweepの範囲、停止条件）
- ハイパーパラメータ（秘密でない範囲）
- ログの形式（CSV/JSON、メトリクス名）

公開しない（原則）：

- 接続情報（ホスト名、IP、VPN識別子）
- 鍵・トークン・認証情報
- 個人識別子、内部の機密データ

混ざりやすいので、公開物と運用メモは最初から分離して管理する（リポジトリ分割、`.gitignore`、別ストレージなど）。

### 17.3 最低限の「再現パッケージ」

第三者が“同じ現象”を確認できる最小セット：

- 定義：$\Lambda$、`step`、`observe`
- 設定：$\Delta t$、ステップ数、初期条件の生成法、乱数種
- 結果：$\Lambda_k$ と代表的メトリクスの時系列、主要な図（任意）
- 環境：依存ライブラリの版、dtype、デバイス種別

最重要は「更新則と観測量の定義が一致している」こと（第13–14章）。

### 17.4 再現性チェック（短いチェックリスト）

- 乱数種を変えても同じ傾向か
- 初期条件分布を変えても壊れないか
- $\Delta t$ を半分にしても同じ結論か（収束性/単調性）
- 離散化（格子/グラフ）を変えても定性的に同じか
- ログから SolPカード（15.4）が復元できるか

### 17.5 この章の要約

- 再現性は Run→Study→Library の階層で設計する。
- 公開物と非公開物を分離し、秘密がログに混ざらない構造にする。
- LoNalogy では特に「更新則と観測量の一致」が再現性の核になる。

---

# Part VII: 応用（宇宙論は別冊）

## 18. 応用テンプレ（問題→SIF選択→観測量→検証）

この章は「任意の対象に LoNalogy を適用するときの道順」をテンプレ化する。
宇宙論など特定ドメインの具体は扱わず、**共通手順**だけを残す。

### 18.1 まず全体像（一本道テンプレ）

1. 問題を定義する（変数・制約・データ・成功条件）
2. 状態表現を決める（$\psi$ と、必要な観測量 $\mathcal{H}[\psi]$）
3. 世界を選ぶ（C-SIF / D-SIF / jiwa-SIF）
4. Lonadian を設計する（$\Lambda=\text{粗さ}+\text{不一致}+\text{制約}+\text{正則化}$）
5. 境界/ポートを確定する（閉系/開系、入力の扱い）
6. 更新則を決める（降下を壊しにくい離散化・積分器）
7. 観測とログを固定する（$\Lambda,\Delta\Lambda$ と監視量）
8. SimP を回して当てる（sweep・反例・しきい値）
9. SolP で正す（条件を明示し、仮定を削る）

ここで「2→4→6→7」が土台、「8→9」が育成ループ。

### 18.2 入力テンプレ（問題定義）

最初に、次を1枚にまとめる：

- **対象**：何を“状態”として扱うか（場、グラフ、列、確率、形状など）
- **目的**：何を最小化/最大化したいか（または何を安定化したいか）
- **制約**：等式/不等式、境界条件、保存量（必要なら）
- **データ**：観測、教師信号、ターゲット、外力（あるなら）
- **成功条件**：収束・精度・制約満足・計算資源など

この「成功条件」が、観測APIの設計（18.7）と停止条件に直結する。

### 18.3 状態表現テンプレ（$\psi$ を何にするか）

LoNalogy の基本は $\psi$ を中心に据えること。
よくある設計は次のいずれか：

1. **対象そのものを $\psi$ とする**：$\psi$ が物理量/場/信号を表す
2. **確率・重みを $\rho=|\psi|^2$ に持たせる**：$\rho$ が分布、$\psi$ はその“平方根＋位相”
3. **離散解の緩和として $\rho$ を使う**：離散ラベルを確率/混合に緩め、後で丸める（jiwa）

設計原則：

- $\Lambda(\psi)$ は常に実数値にする（第14章）
- 観測量は $\psi$ から計算できる形にする（第2章）

### 18.4 世界（SIF）の選択テンプレ

- **C-SIF**：連続場で自然（PDE、境界条件、エネルギー法が効く）
- **D-SIF**：グラフ/離散構造が自然（ラプラシアン $L$、組合せ、ネットワーク）
- **jiwa-SIF**：離散↔連続を往復して「証明しやすい側」に逃がす（第8章・第16章）

実務のコツ：最初は「一つの世界」に固定し、後から jiwa で橋を掛ける。

### 18.5 Lonadian 設計テンプレ（項の分解）

典型的に

$$
\Lambda(\psi)
=
\alpha\,\Lambda_{\mathrm{rough}}(\psi)
\beta\,\Lambda_{\mathrm{fit}}(\psi;\text{data})
\gamma\,\Lambda_{\mathrm{con}}(\psi)
\eta\,\Lambda_{\mathrm{reg}}(\psi)
 \cdots
$$

の和で設計する。ここで：

- **粗さ（rough）**：滑らかさ/拡散/局在の制御
- **当てはめ（fit）**：データ一致、目標形状、外部ポテンシャル
- **制約（con）**：保存量、正規化、境界、禁止領域
- **正則化（reg）**：数値安定のための保険（ただし意味が崩れない範囲で）

例（D-SIFの粗さ）：

$$
\Lambda_{\mathrm{rough}}(\psi)=\langle\psi,L\psi\rangle
\quad(\text{$L$ は半正定値のラプラシアン})
$$

例（C-SIFの粗さ）：

$$
\Lambda_{\mathrm{rough}}(\psi)=\int_{\mathcal{D}} |\nabla\psi(x)|^2\,dx
$$

係数（$\alpha,\beta,\gamma,\eta$）は「理論で決める」より先に、SimP でスケールを当てる（第15章）。

### 18.6 境界・ポートのテンプレ（閉系/開系を先に決める）

境界は“後付け”にすると単調性が壊れやすい（第5章）。

- **閉系**：外からの入出力が無い（まずここで $d\Lambda/dt\le 0$ を固める）
- **開系**：境界/外力/データ注入がある（$\Lambda$ の収支として扱う）

ポート縮約（第9–10章）は「内部を消して境界だけ残す」操作。
大規模系では、最初からポートを定義して縮約したモデルで SimP を回すと、探索が安定しやすい。

### 18.7 更新則テンプレ（壊れにくい計算）

更新則は「連続方程式」より **離散の更新**として固定する（第13章）。

- 勾配流なら、近接（prox）/陰的/半陰的を優先（第13章）
- 保存項＋降下項は分割して、項別 $\Delta\Lambda$ を測れる形にする（第5章・第13章）
- 安全域（射影/クリップ）を入れて、壊れる領域を切る（第12章）

### 18.8 観測APIテンプレ（何を見て判断するか）

最低限、次を時系列で取る（第14章）：

- $\Lambda_k$ と $\Delta\Lambda_k$
- 単調率 $P(\Delta\Lambda_k\le 0)$
- 監視量：$\rho_{\max}$、$G_\psi$、$R$
- 収束指標：$\|\psi^{k+1}-\psi^k\|_2$

停止条件は「見た目」ではなく、成功条件（18.2）に直結させる。

### 18.9 検証テンプレ（SimP→SolP）

- **SimP（当てる）**：しきい値（$\Delta t_{\max}$、係数範囲、境界の安定域）を測り、SolPカードに圧縮（第15章）
- **SolP（正す）**：更新則に対して降下・有界性・収束を分解して証明（第16章）

jiwa を使う場合は「往復誤差」を必ず明示し、誤差が入っても降下がどこまで残るかを評価する（第8章・第16章）。

### 18.10 成果物テンプレ（最終的に残すべきもの）

応用を一つ完成させたら、最低限次を残す：

- **定義**：$\Lambda$、境界（閉/開）、`step`、`observe`
- **結論**：どの条件で何が保証できるか（SolPカード→定理）
- **反例**：どこで壊れるか（しきい値・失敗条件）
- **再現パッケージ**：第17章の最小セット

「成功例」より「壊れた境界」の記録が、次の応用の最短路になる。

### 18.11 D-SIFの典型（B寄り）：ラプラシアンで「粗さ」を作る

離散の典型は「グラフのラプラシアン $L$」で粗さを定義し、そこに目的・制約を足す形。

まず、グラフ $G=(V,E)$ と重み $w_{ij}\ge 0$ を決め、粗さ（平滑化の尺度）を

$$
G_\psi:=\langle\psi,L\psi\rangle
$$

で定義する。多くの場合、これは（定数因子を除いて）

$$
G_\psi\propto\sum_{(i,j)\in E} w_{ij}|\psi_i-\psi_j|^2
$$

と同値に読める。

強度 $\rho=|\psi|^2$ を直接“滑らかにしたい”なら

$$
G_\rho:=\sum_{(i,j)\in E} w_{ij}(\rho_i-\rho_j)^2
$$

のような項を足す（ただし $\rho=|\psi|^2$ と整合する更新を用意する）。

設計テンプレ（例）：

$$
\Lambda(\psi)
=
\alpha\,\langle\psi,L\psi\rangle
+\beta\,\Lambda_{\mathrm{fit}}(\rho;\text{data})
+\gamma\,\Lambda_{\mathrm{con}}(\rho)
$$

ここで $\alpha$ が大きいほど「平滑化が強い」＝硬くなりやすいので、第13章の刻み制約・半陰的化が効く。

### 18.12 jiwa-SIFの典型：離散問題を連続緩和→丸め→誤差で管理する

離散最適化をそのまま SolP するのが重いときは、次の段取りにする：

1. **緩和（D→C）**：離散変数を連続変数（混合/確率）に緩め、$\Lambda$ を連続側で設計する  
2. **降下**：緩和問題の勾配流/近接で $\Lambda$ を下げる（降下・有界性を先に固める）  
3. **丸め（C→D）**：離散解へ戻す（閾値、サンプリング、局所探索など）  
4. **往復誤差の扱い**：丸めによる増分や不一致を「外力/誤差項」としてログ化し、SolP では条件を明示する

ポイントは「丸め」を最終ステップに押し込めること。
それまでは連続の道具（エネルギー法、スペクトル評価、近接法の降下保証）で戦う。

### 18.13 SolPの狙いどころ（B寄り）：$\lambda_{\max}(L)$ で刻み条件を証明する

SimP で「この刻みまでは降下しそう」という“カンニング値”が見えたら、
SolP はそれを上から押さえる形で整える。

典型は、二次の粗さ

$$
\Lambda(\psi)=\langle\psi,L\psi\rangle
$$

のように「線形作用素 $L$」が支配するケース。
このとき更新則（陽的）をどう取るかによって、刻み条件は

- $\Delta t\lesssim 2/\lambda_{\max}(L)$ の形（安定性）
- $\Delta t\le 1/\lambda_{\max}(L)$ の形（単調降下を出したい等）

のように、$\lambda_{\max}(L)$ を中心に書けることが多い。

実務では、SimP で観測した $\Delta t_{\max}$ と $\lambda_{\max}(L)$ の比（定数因子）を揃えにいく。
その後に「勾配の Lipschitz 定数の評価」や「半陰的/近接の降下保証」で SolP を組み立てる（第13章・第16章）。

### 18.14 B寄りの最短ルート（おすすめ運用）

最短で“回る”構成：

1. D-SIFで $G_\psi=\langle\psi,L\psi\rangle$ を入れる
2. 境界（閉系）を固定して、まず $\Lambda$ 単調を出す
3. 硬い平滑化は半陰的/近接へ寄せる
4. sweep は $\Delta t$ と係数（$\alpha,\beta,\gamma$）を中心に回す
5. SolPカードは「刻み条件」「安全域」「境界項」の3点に集約する

この形で部品（補題）が増えると、別の離散問題でも同じ“道”が流用できる。

---

# 付録

## 付録A: 数式一覧

本書で頻出する式を「検索しやすい形」でまとめる（詳細は各章）。

### A.1 状態と分解

- 状態：$\psi=\sqrt{\rho}\,e^{iS}$
- 強度：$\rho=|\psi|^2$
- 位相：$S=\arg(\psi)$（$\psi=0$ では未定義）

### A.2 内積（連続/離散）

- 連続：$\langle f,g\rangle=\int_{\mathcal{D}}\overline{f(x)}\,g(x)\,dx$
- 離散：$\langle u,v\rangle=\sum_{i\in V}\overline{u_i}\,v_i$

### A.3 粗さ（roughness）

- 連続：$\Lambda_{\mathrm{rough}}(\psi)=\int_{\mathcal{D}}|\nabla\psi|^2\,dx$
- 離散：$\Lambda_{\mathrm{rough}}(\psi)=\langle\psi,L\psi\rangle$（$L\succeq 0$）
- エッジ差分：$\sum_{(i,j)\in E} w_{ij}|\psi_i-\psi_j|^2$（$L$ と同値な場合が多い）

### A.4 LoNA方程式（一般形の読み）

- 分解（概念）：保存（回転）＋散逸（降下）＋外力＋ノイズ
- 勾配流（基本形）：$\partial_t\psi=-\dfrac{\delta\Lambda}{\delta\bar{\psi}}$

### A.5 離散時間（更新則）

- 一般の更新：$\psi^{k+1}=\psi^k+\Delta t\,\Phi(\psi^k;\Delta t)$
- 陽的勾配降下：$\psi^{k+1}=\psi^k-\Delta t\,\nabla\Lambda(\psi^k)$
- 近接（prox）更新：
  $$
  \psi^{k+1}=\arg\min_{\psi}\left\{\frac{1}{2\Delta t}\|\psi-\psi^k\|_2^2+\Lambda(\psi)\right\}
  $$

### A.6 圧縮（Schur補完の形）

ブロック行列

$$
A=
\begin{pmatrix}
A_{PP} & A_{PI}\\
A_{IP} & A_{II}
\end{pmatrix}
$$

に対し、内部 $I$ を消すと（形式的に）

$$
Z_{\mathrm{eff}}(s)=sI-A_{PP}-A_{PI}(sI-A_{II})^{-1}A_{IP}
$$

のような有効作用素が現れる（第9–10章）。

## 付録B: 用語集

本書での用語の「固定」を優先する（一般用語の厳密定義とは異なる場合がある）。

- **LoNalogy**：$\psi$ と $\Lambda$ に基づき「降下（Lyapunov）」を軸に設計・実装・検証する枠組み
- **LoNA方程式**：$\psi$ の時間発展（連続でも離散でも「更新則」として読む）
- **Lonadian $\Lambda$**：Lyapunov として扱う汎関数/関数（設計対象）
- **観測API $\mathcal{H}[\psi]$**：$\psi$ から計測値（監視量・制御量）を返す写像
- **SIF**：連続/離散を含む「世界（記述系）」の総称（本書では運用語）
- **C-SIF**：連続場（PDE）として扱う世界
- **D-SIF**：離散グラフ（ラプラシアン $L$）として扱う世界
- **jiwa-SIF**：D↔C を往復して解析/実装をつなぐ橋（近似随伴・往復誤差を含む）
- **SimP**：数値実験で仮説（しきい値・不変量・候補定理）を当てる工程
- **SolP**：仮説を解析学的に正しい命題へ落とす工程（条件・誤差・境界つき）
- **SolPカード**：SimP の結果を証明可能な形（主張・条件・証拠・反例）に圧縮したもの
- **単調率 $P(\Delta\Lambda\le 0)$**：離散更新で「どれくらい降下しているか」の割合指標
- **安全域**：降下・有界性を壊さないために状態/パラメータを制限する領域
- **射影（projection）/クリップ**：安全域からはみ出さないように戻す操作
- **ポート（port）**：境界/インターフェースとして残す自由度（縮約の出入口）
- **LoNA‑Thévenin**：内部自由度を消してポート応答だけ残す縮約（Schur補完）
- **DtN（Dirichlet-to-Neumann）**：境界値から境界流束への写像（連続側の縮約）
- **往復誤差（round-trip error）**：D→C→D などで生じる不一致（外力/誤差項として扱う）
- **C-CIF / D-CIF**：C-SIF / D-SIF を「世界」として圏論的に読むための呼称（詳細は今後追記）

## 付録C: コードテンプレ集

公開用の最小テンプレ（特定環境・接続・秘密情報を含めない）。

### C.1 `step` / `observe` の最小分離

```python
from dataclasses import dataclass
from typing import Any, Dict, Tuple


@dataclass(frozen=True)
class Params:
    # Lonadian の係数や正規化係数など（公開可能な範囲）
    alpha: float
    beta: float


def step(psi, params: Params, dt: float):
    # ここに更新則（第13章）。壊れやすい項は半陰的/近接へ寄せる。
    psi_next = psi  # placeholder
    return psi_next


def observe(psi, params: Params) -> Dict[str, Any]:
    # ここに観測API（第2章・第14章）
    metrics = {
        "Lambda": 0.0,
        "G_psi": 0.0,
        "rho_max": 0.0,
    }
    return metrics
```

### C.2 SimPの標準ループ（ログ重視）

```python
def run(psi0, params: Params, dt: float, steps: int):
    psi = psi0
    history = []
    m_prev = observe(psi, params)
    for k in range(steps):
        psi = step(psi, params, dt)
        m = observe(psi, params)
        m["k"] = k
        m["dLambda"] = m["Lambda"] - m_prev["Lambda"]
        history.append(m)
        m_prev = m
    return psi, history
```

### C.3 SolPカード（テンプレ）

```yaml
claim: "（例）dt <= 2/L なら Lambda_{k+1} <= Lambda_k"
assumptions:
  - "境界は閉系（境界流入なし）"
  - "rho は下限を持つ（または安全域でクリップ）"
  - "勾配は Lipschitz（定数 L の上界）"
evidence:
  monotone_rate: "P(dLambda <= 0) ~ 0.99"
  thresholds:
    dt_max: "0.02"
counterexamples:
  - "境界入力を入れると単調性が崩れる"
notes:
  - "項別 dLambda を測ると外力項が原因"
```

### C.4 例（B寄り/D-SIF）：グラフ平滑化＋データ当てはめ（最小構成）

目的：グラフ上の実ベクトル $u\in\mathbb{R}^{|V|}$ を
「データ $y$ に近く、かつ滑らか」にする。
LoNalogy 記法では「位相ゼロの $\psi$」として $u=\psi$ と見なす。

Lonadian（凸な二次）：

$$
\Lambda(u)
=
\alpha\,u^\top L u
+\frac{\beta}{2}\|u-y\|_2^2
$$

更新則（陽的勾配降下）：

$$
u^{k+1}=u^k-\Delta t\,(2\alpha L u^k+\beta(u^k-y))
$$

SolPの典型主張：$H:=2\alpha L+\beta I$ が対称で $\lambda_{\max}(H)$ が取れるとき、
$0<\Delta t<2/\lambda_{\max}(H)$ なら $\Lambda(u^{k+1})\le \Lambda(u^k)$ が出る。
（実務では $\lambda_{\max}(L)$ を SimP で推定して刻みを当てる。）

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Iterable, Tuple

import numpy as np

Edge = Tuple[int, int, float]  # (i, j, w_ij), w_ij >= 0


@dataclass(frozen=True)
class Graph:
    n: int
    edges: Tuple[Edge, ...]


def laplacian_mv(g: Graph, u: np.ndarray) -> np.ndarray:
    out = np.zeros_like(u)
    for i, j, w in g.edges:
        diff = u[i] - u[j]
        out[i] += w * diff
        out[j] -= w * diff
    return out


def lambda_u(u: np.ndarray, g: Graph, y: np.ndarray, alpha: float, beta: float) -> float:
    Lu = laplacian_mv(g, u)
    smooth = alpha * float(u @ Lu)
    fit = 0.5 * beta * float(np.sum((u - y) ** 2))
    return smooth + fit


def grad_lambda(u: np.ndarray, g: Graph, y: np.ndarray, alpha: float, beta: float) -> np.ndarray:
    return 2.0 * alpha * laplacian_mv(g, u) + beta * (u - y)


def estimate_lambda_max_L(g: Graph, iters: int = 50, seed: int = 0) -> float:
    rng = np.random.default_rng(seed)
    v = rng.standard_normal(g.n)
    v /= np.linalg.norm(v) + 1e-12
    for _ in range(iters):
        w = laplacian_mv(g, v)
        nw = float(np.linalg.norm(w))
        if nw == 0.0:
            return 0.0
        v = w / nw
    Lv = laplacian_mv(g, v)
    return float(v @ Lv)  # Rayleigh quotient


def step_explicit(u: np.ndarray, g: Graph, y: np.ndarray, alpha: float, beta: float, dt: float) -> np.ndarray:
    return u - dt * grad_lambda(u, g, y, alpha, beta)


def observe_u(u: np.ndarray, g: Graph, y: np.ndarray, alpha: float, beta: float) -> Dict[str, Any]:
    Lu = laplacian_mv(g, u)
    lam = alpha * float(u @ Lu) + 0.5 * beta * float(np.sum((u - y) ** 2))
    return {
        "Lambda": lam,
        "G_u": float(u @ Lu),
        "grad_norm": float(np.linalg.norm(2.0 * alpha * Lu + beta * (u - y))),
        "u_max": float(np.max(u)),
        "u_min": float(np.min(u)),
    }
```

SolPカード（この例の完成形）：

```yaml
problem: "Graph Tikhonov denoising"
state: "u in R^{|V|} (treat as phase-zero psi)"
lambda:
  formula: "Lambda(u) = alpha * u^T L u + (beta/2) * ||u - y||^2"
update:
  formula: "u_{k+1} = u_k - dt * (2 alpha L u_k + beta (u_k - y))"
claim:
  - "L is symmetric PSD, beta >= 0, and 0 < dt < 2 / (2 alpha * lambda_max(L) + beta)"
  - "Then Lambda(u_{k+1}) <= Lambda(u_k) (monotone descent)."
assumptions:
  - "Edge weights w_ij >= 0 so that L is PSD"
  - "Closed system: no boundary injection term mixed into the update"
evidence_from_simp:
  - "Estimate lambda_max(L) via power iteration"
  - "Choose dt = 0.9 * 2 / (2 alpha * lambda_max(L) + beta)"
  - "Observe P(dLambda <= 0) ~ 1.0 and grad_norm -> 0"
counterexamples:
  - "dt too large => dLambda > 0 appears, oscillation/divergence"
  - "Negative weights or non-symmetric L => PSD breaks, descent guarantee breaks"
notes:
  - "If alpha is large (strong smoothing), stiffness increases; consider semi-implicit/prox (Chapter 13)"
```

### C.5 例（B寄り/D-SIF）：近接（prox）/半陰的版（刻み制約を緩める）

上の C.4 は「陽的」なので、$\alpha$ が大きい（平滑化が強い）と
$\lambda_{\max}(L)$ による刻み制約が厳しくなる。
これを緩める典型が **近接（prox）** または **半陰的**。

#### C.5.1 近接（prox）= 陰的Euler（おすすめ：単調性が出しやすい）

同じ Lonadian

$$
\Lambda(u)=\alpha\,u^\top L u+\frac{\beta}{2}\|u-y\|_2^2
$$

に対し、近接更新は

$$
u^{k+1}
=
\arg\min_{u}\left\{
\frac{1}{2\Delta t}\|u-u^k\|_2^2+\Lambda(u)
\right\}.
$$

これは線形方程式に落ちる：

$$
\left(I+\Delta t(2\alpha L+\beta I)\right)u^{k+1}
=
u^k+\Delta t\,\beta y.
$$

**SolPの型**（凸な場合）：最適性条件から

$$
\Lambda(u^{k+1})+\frac{1}{2\Delta t}\|u^{k+1}-u^k\|_2^2\le \Lambda(u^k)
$$

が出て、特に $\Lambda(u^{k+1})\le \Lambda(u^k)$ が任意の $\Delta t>0$ で成立しやすい。
（この例では $L\succeq 0$、$\alpha\ge 0$、$\beta\ge 0$ で $\Lambda$ は凸。）

#### C.5.2 半陰的（splitting）：硬い $L$ 項だけ陰的にする

コストを抑えたいときは、硬い平滑化だけ陰的にして

$$
\left(I+2\alpha\Delta t\,L\right)u^{k+1}
=
u^k-\Delta t\,\beta(u^k-y)
$$

のような更新を使う。
このとき刻み制約は「$L$ 由来」ではなく「陽的に残した項（ここでは $\beta$）」側に寄りやすい。
実務では $\Delta t\lesssim 2/\beta$ を目安に SimP で当てる。

#### C.5.3 実装テンプレ（NumPyのみ：行列を作らずCGで解く）

```python
import numpy as np


def cg_solve(mv, b: np.ndarray, x0: np.ndarray, tol: float = 1e-8, max_iter: int = 200) -> np.ndarray:
    x = x0.copy()
    r = b - mv(x)
    p = r.copy()
    rs_old = float(r @ r)
    if rs_old == 0.0:
        return x
    for _ in range(max_iter):
        Ap = mv(p)
        alpha = rs_old / float(p @ Ap)
        x = x + alpha * p
        r = r - alpha * Ap
        rs_new = float(r @ r)
        if rs_new <= tol * tol * rs_old:
            break
        p = r + (rs_new / rs_old) * p
        rs_old = rs_new
    return x


def step_prox(u: np.ndarray, g: Graph, y: np.ndarray, alpha: float, beta: float, dt: float) -> np.ndarray:
    # (I + dt(2a L + b I)) u_next = u + dt b y
    def mv(x: np.ndarray) -> np.ndarray:
        return x + dt * (2.0 * alpha * laplacian_mv(g, x) + beta * x)

    b = u + dt * beta * y
    return cg_solve(mv, b, x0=u)


def step_semi_implicit(u: np.ndarray, g: Graph, y: np.ndarray, alpha: float, beta: float, dt: float) -> np.ndarray:
    # (I + 2a dt L) u_next = u - dt b (u - y)
    def mv(x: np.ndarray) -> np.ndarray:
        return x + (2.0 * alpha * dt) * laplacian_mv(g, x)

    b = (1.0 - dt * beta) * u + dt * beta * y
    return cg_solve(mv, b, x0=u)
```

#### C.5.4 SolPカード（近接版：刻み制約を外す方向）

```yaml
problem: "Graph Tikhonov denoising (prox)"
lambda:
  formula: "Lambda(u) = alpha * u^T L u + (beta/2) * ||u - y||^2"
update:
  formula: "(I + dt(2 alpha L + beta I)) u_{k+1} = u_k + dt * beta * y"
claim:
  - "L is symmetric PSD, alpha >= 0, beta >= 0, and dt > 0"
  - "Then Lambda(u_{k+1}) <= Lambda(u_k) (monotone descent)."
  - "Stronger: Lambda(u_{k+1}) + (1/(2dt))||u_{k+1}-u_k||^2 <= Lambda(u_k)."
assumptions:
  - "Closed system: no boundary injection term mixed into the update"
evidence_from_simp:
  - "Use larger dt than explicit while keeping P(dLambda <= 0) ~ 1.0"
notes:
  - "Each step requires solving an SPD linear system; CG with matvec is typical."
```

## 付録D: チェックリスト

### D.1 実装チェック（最小）

- `step` と `observe` が分離している
- $\Lambda$ の定義が実数値になっている（`real(...)`）
- $\Lambda$ を「測る離散化」と「下げる更新」が一致している（第13章）

### D.2 壊れたときの切り分け

- $\Delta t$ を 1/2 にして改善するか（硬さの疑い）
- 項別 $\Delta\Lambda$ を測って、どの項が増やしているか分かるか（第5章）
- 境界が実は開系になっていないか（第5章・第18章）

### D.3 再現性（Run→Study→Library）

- 乱数種、初期条件生成法、依存ライブラリの版、dtype、デバイスがログにある
- ログから SolPカードが復元できる
- 反例（壊れる条件）が残っている

### D.4 公開安全（必須）

- 接続情報（ホスト名/IP/VPN識別子）が無い
- 鍵・トークン・認証情報が無い
- 個人識別子や内部機密データが無い

### D.5 SolPに渡す前の最終確認

- 主張（候補定理）が「条件つき」で書けている
- しきい値（$\Delta t_{\max}$ 等）と反例が揃っている
- “どの補題が必要か”が見えている（有界性、作用素評価、境界項など）
